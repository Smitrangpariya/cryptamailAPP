----- FILE: D:\CODES\ciphermailApp\frontend\src\App.jsx -----
// Clean React app with just essential components
import React, { useEffect } from "react";
import { Routes, Route, Navigate, useLocation, useNavigate } from "react-router-dom";
import { useAuth } from "./context/AuthContext";
import { useIdleTimer } from "./hooks/useIdleTimer";
import SecurityLogger from "./utils/securityLogger";
import AuthPage from "./pages/AuthPage";
import UnlockMailbox from "./components/Auth/UnlockMailbox";
import MailApp from "./MailApp";
import CryptaMailSplash from "./components/ui/CryptaMailSplash";
import { GoogleAuthProvider } from "./context/GoogleProvider";
import ErrorBoundary from "./components/common/ErrorBoundary";
import { PageTransition } from "./utils/animation.jsx";

export default function App() {
  const { isAuthenticated, isLocked, initialized, clearSession, user } = useAuth();
  const location = useLocation();
  const navigate = useNavigate();

  // ‚ö†Ô∏è SECURITY: Set up idle timer for auto-logout (15 minutes)
  useIdleTimer(() => {
    if (isAuthenticated) {
      if (import.meta.env.DEV) {
        console.warn('‚è±Ô∏è Session timeout triggered due to inactivity');
      }
      SecurityLogger.logLogout(user?.id || 'unknown', 'session_timeout');
      clearSession();
      navigate('/login', { replace: true });
    }
  }, 15 * 60 * 1000); // 15 minutes

  // Listen for unauthorized events to globally handle session expiry
  useEffect(() => {
    const handleUnauthorized = () => {
      if (isAuthenticated) {
        if (import.meta.env.DEV) {
          console.log('Session expired or invalid. Clearing session and redirecting to login.');
        }
        clearSession();
        // Use setTimeout to avoid race conditions
        setTimeout(() => {
          navigate('/login', { replace: true });
        }, 100);
      }
    };

    window.addEventListener('unauthorized', handleUnauthorized);

    return () => {
      window.removeEventListener('unauthorized', handleUnauthorized);
    };
  }, [isAuthenticated, clearSession, navigate]);

  // Show loading spinner while auth initializes
  if (!initialized) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-4"></div>
          <p className="text-gray-600 dark:text-gray-400">Initializing secure mailbox...</p>
        </div>
      </div>
    );
  }

  // Only log in development
  if (import.meta.env.DEV) {
    console.debug('üîê App state:', { isAuthenticated, isLocked, initialized });
    console.debug('üåê Environment:', {
      client: !!import.meta.env.VITE_GOOGLE_CLIENT_ID,
      api: import.meta.env.VITE_API_BASE_URL
    });
  }

  return (
    <ErrorBoundary>
      <a href="#main-content" className="skip-to-main">
        Skip to main content
      </a>
      <GoogleAuthProvider>
        <Routes>
          <Route
            path="/login"
            element={
              !isAuthenticated && initialized ? (
                <PageTransition location="login">
                  <AuthPage />
                </PageTransition>
              ) : (
                <Navigate to="/" replace />
              )
            }
          />

          <Route
            path="/register"
            element={
              !isAuthenticated && initialized ? (
                <PageTransition location="register">
                  <AuthPage />
                </PageTransition>
              ) : (
                <Navigate to="/" replace />
              )
            }
          />

          <Route
            path="/unlock"
            element={
              isAuthenticated && isLocked ? (
                <PageTransition location="unlock">
                  <UnlockMailbox />
                </PageTransition>
              ) : (
                <Navigate to="/" replace />
              )
            }
          />

          <Route
            path="/splash"
            element={
              <PageTransition location="splash">
                <CryptaMailSplash onComplete={() => navigate('/login')} />
              </PageTransition>
            }
          />

          <Route
            path="/*"
            element={
              !isAuthenticated ? (
                <Navigate to="/login" replace />
              ) : isLocked ? (
                <Navigate to="/unlock" replace />
              ) : (
                <PageTransition location="main">
                  <MailApp />
                </PageTransition>
              )
            }
          />
        </Routes>
      </GoogleAuthProvider>
    </ErrorBoundary>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\index.css -----
/* Import auth component styles */
@import './components/Auth/authAnimated.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Respect prefers-reduced-motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Smooth theme transitions with accessibility in mind */
* {
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

/* Skip to main content for accessibility */
.skip-to-main {
  position: absolute;
  top: -40px;
  left: 6px;
  background: #000;
  color: white;
  padding: 8px;
  text-decoration: none;
  z-index: 100;
  border-radius: 4px;
}

.skip-to-main:focus {
  top: 6px;
}

/* Focus visible improvements for better keyboard navigation */
.focus-visible:focus {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
  border-radius: 4px;
}

/* Animation performance optimizations */
.gpu-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
  perspective: 1000px;
}

/* Dark mode specific animation fixes */
.dark .motion-safe {
  will-change: transform, opacity;
}

/* Base styles */
body {
    @apply bg-slate-50 text-slate-900 dark:bg-slate-950 dark:text-slate-100;
}

/* Legacy layout dark-mode compatibility & Scrollbars */
.dark ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.dark ::-webkit-scrollbar-track {
    background: #0f172a;
}

.dark ::-webkit-scrollbar-thumb {
    background: #334155;
    border-radius: 4px;
}

.dark ::-webkit-scrollbar-thumb:hover {
    background: #475569;
}

/* Input fix (VERY IMPORTANT) */
input,
textarea,
select {
    @apply bg-white text-gray-900 border-gray-300 focus:ring-blue-500 focus:border-blue-500 dark:bg-slate-800 dark:border-slate-700 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500;
}

/* Card & Container backgrounds for consistency */
.card {
    @apply bg-white dark:bg-slate-900 shadow rounded-lg;
}

/* Override plugin styles if necessary */
.dark .app,
.dark .main-container,
.dark .email-container {
    background-color: transparent;
    /* Let body handle it or use specific */
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\MailApp.jsx -----
import { useState, useEffect, useRef } from "react";
import { AnimatePresence, motion } from "framer-motion";
import { useAuth } from "./context/AuthContext";
import { useTheme } from "./context/ThemeContext";
import { emailAPI } from "./services/apiService";
import TopBar from "./components/Layout/TopBar";
import Sidebar from "./components/Layout/Sidebar";
import EmailList from "./components/Email/EmailList";
import EmailDetail from "./components/Email/EmailDetail";
import ComposeModal from "./components/Email/ComposeModal";
import Settings from "./components/Settings";
import AnimatedSectionBackground from "./components/ui/AnimatedSectionBackground";
import LoadingSkeleton from "./components/ui/LoadingSkeleton";
import { useKeyboardShortcuts } from "./hooks/useKeyboardShortcuts";

export default function MailApp() {
  const { user, privateKey, logout } = useAuth();
  const { toggleTheme } = useTheme();
  const searchInputRef = useRef(null);
  
  const [activeView, setActiveView] = useState("inbox");
  const [emails, setEmails] = useState([]);
  const [selectedEmail, setSelectedEmail] = useState(null);
  const [showCompose, setShowCompose] = useState(false);
  const [composeData, setComposeData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);

  useEffect(() => {
    loadEmails(activeView);

    let interval;
    if (activeView === "inbox") {
      interval = setInterval(() => {
        loadEmails("inbox", true);
      }, 10000); // Poll every 10 seconds
    }

    return () => {
      if (interval) clearInterval(interval);
    };
  }, [activeView]);

const loadEmails = async (view, silent = false) => {
    if (!silent) setLoading(true);
    if (!silent) setSelectedEmail(null);
    try {
      let res;
      if (view === "inbox") {
        res = await emailAPI.getInbox();
      } else if (view === "sent") {
        res = await emailAPI.getSent();
      } else if (view === "drafts") {
        res = await emailAPI.getDrafts();
      } else if (view === "trash") {
        res = await emailAPI.getTrash();
      } else if (view === "spam") {
        res = await emailAPI.getSpam();
      }
      
      // Validate response before setting emails
      if (!res || !res.data) {
        throw new Error('Invalid response from server');
      }
      
      setEmails(res.data);
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error("Failed to load emails", error);
      }
      if (!silent) {
        setEmails([]); // Clear emails on error to prevent stale data
      }
    } finally {
      if (!silent) setLoading(false);
    }
  };

  const handleEmptyTrash = async () => {
    try {
      const response = await emailAPI.emptyTrash();
      const deletedCount = response.data?.deletedCount || 0;
      
      // Show success message
      alert(`Successfully deleted ${deletedCount} email${deletedCount !== 1 ? 's' : ''} from trash.`);
      
      // Reload trash emails
      await loadEmails('trash');
      
      // Clear selected email if it was in trash
      if (activeView === 'trash') {
        setSelectedEmail(null);
      }
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error("Failed to empty trash:", error);
      }
      // Error is already handled in EmailList component
      throw error;
    }
  };

  const handleEmailRefresh = () => {
    loadEmails(activeView);
  };

  return (
    <div id="main-content" className="min-h-screen bg-slate-50 dark:bg-slate-950 text-slate-900 dark:text-slate-100 flex flex-col font-sans transition-colors duration-200">
      <TopBar onLogout={logout} userAddress={user?.address || ""} />

      <div className="flex flex-1 overflow-hidden h-[calc(100vh-64px)]">
        <motion.div
          initial={false}
          animate={{ width: sidebarCollapsed ? 80 : 256 }}
          transition={{ duration: 0.3, ease: "easeInOut" }}
          className="bg-slate-100 dark:bg-slate-950 flex flex-col border-r border-slate-200 dark:border-slate-800 relative"
        >
          <Sidebar
            activeView={activeView}
            onViewChange={setActiveView}
            onCompose={() => setShowCompose(true)}
            collapsed={sidebarCollapsed}
            onToggleCollapse={() => setSidebarCollapsed(!sidebarCollapsed)}
          />
        </motion.div>

        <div className="flex-1 flex flex-col relative overflow-hidden bg-white dark:bg-slate-900 shadow-xl rounded-tl-2xl border-l border-slate-200 dark:border-slate-800">
            {activeView === 'settings' ? (
              <div className="h-full overflow-y-auto">
                <Settings />
              </div>
            ) : loading ? (
              <LoadingSkeleton count={8} />
            ) : (
              <AnimatePresence mode="wait">
                <motion.div
                  key={activeView}
                  initial={{ opacity: 0, x: -20 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 20 }}
                  transition={{ duration: 0.2 }}
                  className="h-full overflow-hidden"
                >
                    <EmailList
                      emails={emails}
                      onEmailClick={(email) => {
                        if (email === null) {
                          // Handle refresh request from EmailList
                          handleEmailRefresh();
                        } else {
                          setSelectedEmail(email);
                        }
                      }}
                      onRefresh={handleEmailRefresh}
                      selectedEmailId={selectedEmail?.id}
                      viewType={activeView}
                      onEmptyTrash={activeView === "trash" ? handleEmptyTrash : undefined}
                    />
                </motion.div>
              </AnimatePresence>
            )}

            <AnimatePresence>
              {selectedEmail && privateKey && (
                <motion.div
                  initial={{ opacity: 0, x: "100%" }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: "100%" }}
                  transition={{ type: "spring", damping: 25, stiffness: 200 }}
                  className="absolute inset-0 bg-white dark:bg-slate-900 z-10 shadow-2xl"
                >
                  <div className="h-full overflow-y-auto">
                    <EmailDetail
                      email={selectedEmail}
                      userPrivateKey={privateKey}
                      onClose={() => setSelectedEmail(null)}
                      viewType={activeView}
                      onEdit={(data) => {
                        setComposeData(data);
                        setSelectedEmail(null);
                        setShowCompose(true);
                      }}
                      onDelete={async (id) => {
                        const confirmMessage = activeView === "trash" 
                          ? "Are you sure you want to permanently delete this email? This action cannot be undone."
                          : "Are you sure you want to delete this email?";
                        
                        if (confirm(confirmMessage)) {
                          try {
                            if (activeView === "drafts") {
                              await emailAPI.deleteDraft(id);
                            } else if (activeView === "trash") {
                              await emailAPI.permanentlyDeleteEmail(id);
                            } else {
                              await emailAPI.deleteEmail(id);
                            }
                            setSelectedEmail(null);
                            loadEmails(activeView);
                          } catch (error) {
                            alert("Failed to delete email");
                            if (import.meta.env.DEV) console.error(error);
                          }
                        }
                      }}
                    />
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
                  </div>
      </div>

      {showCompose && (
        <ComposeModal
          onClose={() => {
            setShowCompose(false);
            setComposeData(null);
          }}
          onEmailSent={() => {
            setShowCompose(false);
            setComposeData(null);
            if (activeView === 'drafts' || activeView === 'sent') loadEmails(activeView);
            else setActiveView("sent");
          }}
          initialData={composeData}
        />
      )}

      {/* Keyboard Shortcuts */}
      {useKeyboardShortcuts({
        onCompose: () => setShowCompose(true),
        onRefresh: () => loadEmails(activeView),
        onSearch: () => {
          const searchInput = document.querySelector('input[placeholder*="Search"]');
          if (searchInput) {
            searchInput.focus();
            searchInput.select();
          }
        },
        onToggleTheme: toggleTheme,
        onSelectEmail: (email) => {
          if (typeof email === 'object' && email.id) {
            setSelectedEmail(email);
          }
        },
        onDeleteEmail: async (emailId) => {
          const email = emails.find(e => e.id === emailId);
          if (!email) return;
          
          const confirmMessage = activeView === "trash" 
            ? "Are you sure you want to permanently delete this email? This action cannot be undone."
            : "Are you sure you want to delete this email?";
          
          if (confirm(confirmMessage)) {
            try {
              if (activeView === "drafts") {
                await emailAPI.deleteDraft(emailId);
              } else if (activeView === "trash") {
                await emailAPI.permanentlyDeleteEmail(emailId);
              } else {
                await emailAPI.deleteEmail(emailId);
              }
              setSelectedEmail(null);
              loadEmails(activeView);
            } catch (error) {
              alert("Failed to delete email");
              if (import.meta.env.DEV) console.error(error);
            }
          }
        },
        onReply: (emailId) => {
          const email = emails.find(e => e.id === emailId);
          if (email) {
            setComposeData({
              to: email.fromUsername ? `${email.fromUsername}@smail.in` : '',
              subject: email.subject ? `Re: ${email.subject}` : '',
              body: `\n\n---\nOn ${new Date(email.timestamp).toLocaleDateString()}, ${email.fromUsername} wrote:\n`,
              replyToEmailId: emailId
            });
            setSelectedEmail(null);
            setShowCompose(true);
          }
        },
        onForward: (emailId) => {
          const email = emails.find(e => e.id === emailId);
          if (email) {
            setComposeData({
              to: '',
              subject: email.subject ? `Fwd: ${email.subject}` : '',
              body: `\n\n--- Forwarded message ---\nFrom: ${email.fromUsername}\nDate: ${new Date(email.timestamp).toLocaleDateString()}\nSubject: ${email.subject}\n\n`,
              forwardEmailId: emailId
            });
            setSelectedEmail(null);
            setShowCompose(true);
          }
        },
        onStarEmail: async (emailId) => {
          const email = emails.find(e => e.id === emailId);
          if (email) {
            try {
              const newStarredState = !email.isStarred;
              await emailAPI.toggleStar(emailId, newStarredState);
              setEmails(prevEmails => 
                prevEmails.map(e => 
                  e.id === emailId ? { ...e, isStarred: newStarredState } : e
                )
              );
            } catch (error) {
              if (import.meta.env.DEV) console.error("Failed to toggle star:", error);
            }
          }
        },
        onMarkImportant: async (emailId) => {
          const email = emails.find(e => e.id === emailId);
          if (email) {
            try {
              const newImportantState = !email.isImportant;
              await emailAPI.toggleImportant(emailId, newImportantState);
              setEmails(prevEmails => 
                prevEmails.map(e => 
                  e.id === emailId ? { ...e, isImportant: newImportantState } : e
                )
              );
            } catch (error) {
              if (import.meta.env.DEV) console.error("Failed to toggle important:", error);
            }
          }
        },
        onToggleRead: async (emailId) => {
          const email = emails.find(e => e.id === emailId);
          if (email) {
            try {
              await emailAPI.markAsRead(emailId);
              setEmails(prevEmails => 
                prevEmails.map(e => 
                  e.id === emailId ? { ...e, isRead: !e.isRead } : e
                )
              );
            } catch (error) {
              if (import.meta.env.DEV) console.error("Failed to toggle read status:", error);
            }
          }
        },
        onMoveToFolder: (emailId, folder) => {
          if (!emailId) {
            // Just navigate to folder
            setActiveView(folder);
          } else {
            // Move email to folder (this would require additional API endpoints)
            if (import.meta.env.DEV) console.debug(`Moving email ${emailId} to ${folder}`);
          }
        },
        viewMode: activeView,
        emails,
        selectedEmailId: selectedEmail?.id,
        activeView
      })}
    </div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\AuthPage.jsx -----
import { useState } from "react";
import { useNavigate } from "react-router-dom";
import { useAuth } from "../../context/AuthContext";
import { getPasswordStrength } from "../../utils/passwordStrength";
import CryptaMailLoader from "../ui/CryptaMailLoader";
import CryptaMailLogo from "../ui/CryptaMailLogo";

export default function AuthPage() {
  const [mode, setMode] = useState("login");
  const [username, setUsername] = useState("");
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");

  const { login, register, loading } = useAuth();
  const navigate = useNavigate();

  const strength = getPasswordStrength(password);

  const submit = async (e) => {
    e.preventDefault();
    setError("");

    if (mode === "register" && strength < 3) {
      setError("Password is too weak");
      return;
    }

    try {
      if (mode === "login") {
        await login(username, password);
      } else {
        await register(username, password);
      }
      navigate("/", { replace: true });
    } catch (err) {
      setError(err.message || "Authentication failed");
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br
                    from-secure-primary to-secure-secondary
                    dark:from-secure-dark dark:to-black">

<div className="bg-white dark:bg-gray-900 dark:text-white
                      p-8 rounded-2xl shadow-xl w-full max-w-md">

        <div className="flex justify-center mb-6">
          <CryptaMailLogo className="text-secure-primary" />
        </div>

        <h1 className="text-2xl font-bold text-center">
          {mode === "login" ? "Sign In" : "Create Account"}
        </h1>

        <form onSubmit={submit} className="mt-6 space-y-4">
          <input
            placeholder="Username"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
            className="w-full p-3 rounded-lg border"
            required
          />

          <input
            type="password"
            placeholder="Password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            className="w-full p-3 rounded-lg border"
            required
          />

          {/* Password strength meter */}
          {mode === "register" && (
            <div className="text-sm">
              <div className="flex gap-1">
                {[0, 1, 2, 3].map((i) => (
                  <div
                    key={i}
                    className={`h-2 flex-1 rounded
                      ${strength > i
                        ? strength >= 4
                          ? "bg-green-500"
                          : strength >= 3
                          ? "bg-yellow-500"
                          : "bg-red-500"
                        : "bg-gray-300 dark:bg-gray-700"}`}
                  />
                ))}
              </div>
              <p className="mt-1">
                {strength < 2 && "Weak"}
                {strength === 2 && "Medium"}
                {strength >= 3 && "Strong"}
              </p>
            </div>
          )}

          {error && <p className="text-red-500 text-sm">{error}</p>}

<button
            disabled={loading}
            className="w-full bg-secure-primary text-white py-3 rounded-lg flex items-center justify-center gap-2">
            {loading ? (
              <>
                <CryptaMailLoader size={20} />
                <span>Please wait‚Ä¶</span>
              </>
            ) : mode === "login" ? "Sign In" : "Sign Up"}
          </button>
        </form>

        <p className="text-sm text-center mt-4">
          {mode === "login" ? "No account?" : "Already registered?"}{" "}
          <button
            onClick={() => setMode(mode === "login" ? "register" : "login")}
            className="text-secure-primary font-semibold">
            {mode === "login" ? "Sign Up" : "Sign In"}
          </button>
        </p>
      </div>
    </div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\Register.jsx -----
// src/components/Auth/Register.jsx

import { useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import {
    formatAppEmail,
    getUsernameError,
    normalizeUsername,
} from '../../utils/addressUtils';
import GoogleLogin from './GoogleLogin';

export default function Register({ onSwitchToLogin }) {
    const { register, loading, error: authError } = useAuth();

const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [confirmPassword, setConfirmPassword] = useState('');
    const [dateOfBirth, setDateOfBirth] = useState('');
    const [error, setError] = useState('');
    const [generatingKeys, setGeneratingKeys] = useState(false);

    // Handle username field change
    const handleUsernameChange = (e) => {
        const value = normalizeUsername(e.target.value);
        setUsername(value);
        setError('');
    };

// Calculate age from date of birth
    const calculateAge = (dob) => {
        const today = new Date();
        const birthDate = new Date(dob);
        let age = today.getFullYear() - birthDate.getFullYear();
        const monthDiff = today.getMonth() - birthDate.getMonth();
        
        if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
            age--;
        }
        
        return age;
    };

    // Validate all form fields
    const validateForm = () => {
        const usernameErr = getUsernameError(username);
        if (usernameErr) {
            setError(usernameErr);
            return false;
        }

        if (!dateOfBirth) {
            setError('Date of birth is required');
            return false;
        }

        const age = calculateAge(dateOfBirth);
        if (age < 14) {
            setError('You must be at least 14 years old to register');
            return false;
        }

        if (password !== confirmPassword) {
            setError('Passwords do not match');
            return false;
        }

        if (password.length < 8) {
            setError('Password must be at least 8 characters');
            return false;
        }

        return true;
    };

    // Submit registration
    const handleSubmit = async (e) => {
        e.preventDefault();
        setError('');

        if (!validateForm()) return;

try {
            setGeneratingKeys(true);
            await register(username, password, dateOfBirth);
            // AuthContext will auto-login or redirect
        } catch (err) {
            setError(err.message || 'Registration failed');
            setGeneratingKeys(false);
        }
    };

    // Safe address preview (avoids crash)
    let displayedAddress = '';
    if (username && !getUsernameError(username)) {
        try {
            displayedAddress = formatAppEmail(username);
        } catch {
            displayedAddress = '';
        }
    }

    return (
        <div className="auth-container">
            <div className="auth-card">
<div className="auth-header">
                    <h1>CryptaMail</h1>
                    <p>Create your @smail.in account</p>
                </div>

                <form onSubmit={handleSubmit} className="auth-form">
                    {(error || authError) && (
                        <div className="error-message">{error || authError}</div>
                    )}

                    {generatingKeys && (
                        <div className="info-message">
                            üîê Generating encryption keys... This may take a moment.
                        </div>
                    )}

                    {/* Username Field */}
                    <div className="form-group">
                        <label htmlFor="username">Username</label>
                        <input
                            id="username"
                            type="text"
                            value={username}
                            onChange={handleUsernameChange}
                            required
                            placeholder="alice"
                            disabled={loading || generatingKeys}
                            autoComplete="username"
                            autoFocus
                        />

                        {/* Username validation hint */}
                        {username && getUsernameError(username) && (
                            <small className="form-error">
                                {getUsernameError(username)}
                            </small>
                        )}

                        {/* Valid username preview */}
                        {username && !getUsernameError(username) && (
                            <small className="form-hint">
                                Your email will be: <strong>{displayedAddress}</strong>
                            </small>
                        )}
                    </div>

                    {/* Password Field */}
                    <div className="form-group">
                        <label htmlFor="password">Password</label>
                        <input
                            id="password"
                            type="password"
                            value={password}
                            onChange={(e) => setPassword(e.target.value)}
                            required
                            placeholder="At least 8 characters"
                            disabled={loading || generatingKeys}
                            autoComplete="new-password"
                        />
                    </div>

{/* Date of Birth Field */}
                    <div className="form-group">
                        <label htmlFor="dateOfBirth">Date of Birth</label>
                        <input
                            id="dateOfBirth"
                            type="date"
                            value={dateOfBirth}
                            onChange={(e) => setDateOfBirth(e.target.value)}
                            required
                            max={new Date().toISOString().split('T')[0]}
                            disabled={loading || generatingKeys}
                        />
                        {dateOfBirth && (
                            <small className="form-hint">
                                Age: {calculateAge(dateOfBirth)} years
                                {calculateAge(dateOfBirth) < 14 && (
                                    <span className="form-error ml-2">
                                        (Must be 14+ years)
                                    </span>
                                )}
                            </small>
                        )}
                    </div>

                    {/* Confirm Password */}
                    <div className="form-group">
                        <label htmlFor="confirmPassword">Confirm Password</label>
                        <input
                            id="confirmPassword"
                            type="password"
                            value={confirmPassword}
                            onChange={(e) => setConfirmPassword(e.target.value)}
                            required
                            placeholder="Re-enter password"
                            disabled={loading || generatingKeys}
                            autoComplete="new-password"
                        />
                    </div>

                    {/* Submit */}
                    <button
                        type="submit"
                        className="btn btn-primary"
                        disabled={loading || generatingKeys}
                    >
                        {generatingKeys
                            ? 'Generating Keys...'
                            : loading
                            ? 'Creating Account...'
                            : 'Register'}
                    </button>
                </form>

{/* Divider */}
                <div className="relative my-6">
                    <div className="absolute inset-0 flex items-center">
                        <div className="w-full border-t border-slate-300 dark:border-slate-600"></div>
                    </div>
                    <div className="relative flex justify-center text-sm">
                        <span className="px-2 bg-white dark:bg-slate-900 text-slate-500 dark:text-slate-400">
                            Or register with
                        </span>
                    </div>
                </div>

                {/* Google OAuth Button (standardized) */}
                <GoogleLogin isRegister={true} />

                {/* Switch to Login */}
                <div className="auth-footer">
                    Already have an account?{' '}
                    <button
                        className="link-button"
                        onClick={onSwitchToLogin}
                        disabled={loading || generatingKeys}
                    >
                        Login
                    </button>
                </div>

                {/* Security Notice */}
                <div className="encryption-notice">
                    üîí <strong>End-to-End Encrypted</strong>
                    <br />
                    <small>
                        Your encryption keys are generated in your browser.
                        Your private key never leaves your device in plaintext.
                    </small>
                </div>

                <div className="security-warning">
                    ‚ö†Ô∏è <strong>Important:</strong>
                    If you forget your password, you lose access to your encrypted emails.
                    There is no recovery.
                </div>
            </div>
        </div>
    );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\RegisterForm.jsx -----
import { useState } from 'react';
import { motion } from 'framer-motion';
import { useAuth } from '../../context/AuthContext';
import {
  formatAppEmail,
  getUsernameError,
  normalizeUsername,
} from '../../utils/addressUtils';
import AuthLogo from '../common/Logo';
import GoogleLogin from './GoogleLogin';
import { authVariants } from '../../utils/animation';

export default function RegisterForm({ onToggle }) {
  const { register, loading, error: authError } = useAuth();

  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [dateOfBirth, setDateOfBirth] = useState('');
  const [error, setError] = useState('');
  const [generatingKeys, setGeneratingKeys] = useState(false);

  // Handle username field change
  const handleUsernameChange = (e) => {
    const value = normalizeUsername(e.target.value);
    setUsername(value);
    setError('');
  };

  // Calculate age from date of birth
  const calculateAge = (dob) => {
    const today = new Date();
    const birthDate = new Date(dob);
    let age = today.getFullYear() - birthDate.getFullYear();
    const monthDiff = today.getMonth() - birthDate.getMonth();
    
    if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
      age--;
    }
    
    return age;
  };

  // Validate all form fields
  const validateForm = () => {
    const usernameErr = getUsernameError(username);
    if (usernameErr) {
      setError(usernameErr);
      return false;
    }

    if (!dateOfBirth) {
      setError('Date of birth is required');
      return false;
    }

    const age = calculateAge(dateOfBirth);
    if (age < 14) {
      setError('You must be at least 14 years old to register');
      return false;
    }

    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return false;
    }

    if (password.length < 8) {
      setError('Password must be at least 8 characters');
      return false;
    }

    return true;
  };

  // Submit registration
  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');

    if (!validateForm()) return;

    try {
      setGeneratingKeys(true);
      await register(username, password, dateOfBirth);
      // AuthContext will auto-login or redirect
    } catch (err) {
      setError(err.message || 'Registration failed');
      setGeneratingKeys(false);
    }
  };

  // Safe address preview (avoids crash)
  let displayedAddress = '';
  if (username && !getUsernameError(username)) {
    try {
      displayedAddress = formatAppEmail(username);
    } catch {
      displayedAddress = '';
    }
  }

  return (
    <motion.div 
      className="w-full max-w-md mx-auto"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      transition={{ duration: 0.3 }}
    >
      <AuthLogo />

      <motion.form 
        onSubmit={handleSubmit} 
        className="space-y-6"
        initial={{ y: 20, opacity: 0 }}
        animate={{ y: 0, opacity: 1 }}
        transition={{ duration: 0.4, delay: 0.1 }}
      >
        {(error || authError) && (
          <motion.div 
            className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm"
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
          >
            {error || authError}
          </motion.div>
        )}

        <div className="space-y-4">
          <motion.div
            initial={{ x: -20, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ duration: 0.3, delay: 0.2 }}
          >
            <label htmlFor="reg-username" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Username
            </label>
            <input
              id="reg-username"
              type="text"
              value={username}
              onChange={handleUsernameChange}
              placeholder="Choose a username"
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              disabled={loading || generatingKeys}
              autoComplete="username"
            />
            {displayedAddress && (
              <motion.p 
                className="mt-1 text-xs text-gray-500 dark:text-gray-400"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ duration: 0.2 }}
              >
                Your email: {displayedAddress}
              </motion.p>
            )}
          </motion.div>

          <motion.div
            initial={{ x: -20, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ duration: 0.3, delay: 0.3 }}
          >
            <label htmlFor="reg-password" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Password
            </label>
            <input
              id="reg-password"
              type="password"
              value={password}
              onChange={(e) => {
                setPassword(e.target.value);
                setError('');
              }}
              placeholder="Create a strong password"
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              disabled={loading || generatingKeys}
              autoComplete="new-password"
            />
          </motion.div>

          <motion.div
            initial={{ x: -20, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ duration: 0.3, delay: 0.4 }}
          >
            <label htmlFor="reg-confirm-password" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Confirm Password
            </label>
            <input
              id="reg-confirm-password"
              type="password"
              value={confirmPassword}
              onChange={(e) => {
                setConfirmPassword(e.target.value);
                setError('');
              }}
              placeholder="Confirm your password"
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              disabled={loading || generatingKeys}
              autoComplete="new-password"
            />
          </motion.div>

          <motion.div
            initial={{ x: -20, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            transition={{ duration: 0.3, delay: 0.5 }}
          >
            <label htmlFor="reg-dob" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Date of Birth
            </label>
            <input
              id="reg-dob"
              type="date"
              value={dateOfBirth}
              onChange={(e) => {
                setDateOfBirth(e.target.value);
                setError('');
              }}
              max={new Date().toISOString().split('T')[0]}
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              disabled={loading || generatingKeys}
            />
            <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
              Must be at least 14 years old
            </p>
          </motion.div>
        </div>

        <motion.div
          initial={{ y: 20, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          transition={{ duration: 0.3, delay: 0.6 }}
          className="space-y-4"
        >
          <motion.button
            type="submit"
            disabled={loading || generatingKeys || !username || !password || !confirmPassword || !dateOfBirth}
            className="w-full py-3 px-4 bg-gradient-to-r from-indigo-600 to-indigo-700 hover:from-indigo-700 hover:to-indigo-800 disabled:from-gray-400 disabled:to-gray-500 
                     text-white font-semibold rounded-lg shadow-lg hover:shadow-xl disabled:shadow-none 
                     transition-all duration-300 disabled:cursor-not-allowed
                     flex items-center justify-center gap-2 relative overflow-hidden group"
            whileHover={{ scale: loading || generatingKeys ? 1 : 1.02 }}
            whileTap={{ scale: loading || generatingKeys ? 1 : 0.98 }}
          >
            {(loading || generatingKeys) ? (
              <>
                <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                {generatingKeys ? 'Generating Keys...' : 'Creating Account...'}
              </>
            ) : (
              'Create Account'
            )}
          </motion.button>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300 dark:border-gray-600"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white dark:bg-gray-800 text-gray-500 dark:text-gray-400">
                Or continue with
              </span>
            </div>
          </div>

          <GoogleLogin isRegister={true} />
        </motion.div>
      </motion.form>
    </motion.div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\SimpleGoogleButton.jsx -----
import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { useAuth } from '../../context/AuthContext';

export default function SimpleGoogleButton() {
    const { googleSignIn, loading } = useAuth();
    const [googleLoading, setGoogleLoading] = useState(false);
    const [scriptLoaded, setScriptLoaded] = useState(false);
    const [error, setError] = useState('');

    useEffect(() => {
        console.log('Loading Google API script...');
        
        // Load Google API script
        const loadGoogleScript = () => {
            // Check if script is already loaded
            if (window.gapi || document.querySelector('script[src*="google.com"]')) {
                console.log('Google script already exists');
                setScriptLoaded(true);
                setTimeout(() => initializeGoogleAuth(), 500);
                return;
            }

            const script = document.createElement('script');
            script.src = 'https://apis.google.com/js/platform.js';
            script.async = true;
            script.defer = true;
            script.onload = () => {
                console.log('Google script loaded successfully');
                setScriptLoaded(true);
                setTimeout(() => initializeGoogleAuth(), 1000);
            };
            script.onerror = (err) => {
                console.error('Failed to load Google API script:', err);
                setError('Failed to load Google authentication. Please refresh the page.');
            };
            document.head.appendChild(script);

            return () => {
                if (document.head.contains(script)) {
                    document.head.removeChild(script);
                }
            };
        };

        loadGoogleScript();
    }, []);

const initializeGoogleAuth = () => {
        console.log('Initializing Google auth...');
        if (window.gapi) {
            window.gapi.load('auth2', () => {
                window.gapi.auth2.init({
                    client_id: '738325871972-17u1a4eg758tb79nte81oijres6rachm.apps.googleusercontent.com',
                    scope: 'profile email',
                });
                console.log('Google auth initialized');
            });
        } else {
            console.error('GAPI not available');
        }
    };

    const handleGoogleSignIn = async () => {
        console.log('Google sign-in clicked');
        try {
            setGoogleLoading(true);
            setError('');

            if (!window.gapi || !window.gapi.auth2) {
                throw new Error('Google API not loaded. Please refresh the page.');
            }

            // Get auth2 instance
            const auth2 = window.gapi.auth2.getAuthInstance();

            // Sign in with popup
            const googleUser = await auth2.signIn({
                prompt: 'select_account'
            });

            // Get user profile information
            const profile = googleUser.getBasicProfile();
            const authResponse = googleUser.getAuthResponse();

            const userData = {
                email: profile.getEmail(),
                name: profile.getName(),
                givenName: profile.getGivenName(),
                familyName: profile.getFamilyName(),
                imageUrl: profile.getImageUrl(),
                id: profile.getId(),
                token: authResponse.id_token,
            };

            console.log('Google user data:', userData);

            await googleSignIn(userData, '');

        } catch (err) {
            console.error('Google sign-in error:', err);
            
            let errorMessage = 'Google sign-in failed';
            if (err.response) {
                // API error
                errorMessage = err.response.data?.message || err.response.data || err.response.statusText || 'Server error';
            } else if (err.request) {
                // Network error
                errorMessage = 'Network error. Please check your connection.';
            } else {
                // Other error
                errorMessage = err.message || 'An unexpected error occurred';
            }
            
            setError(errorMessage);
        } finally {
            setGoogleLoading(false);
        }
    };

    const fetchGoogleUserInfo = async (accessToken) => {
        const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {
            headers: { 'Authorization': `Bearer ${accessToken}` }
        });
        if (!response.ok) {
            throw new Error('Failed to fetch user info');
        }
        return await response.json();
    };

    return (
        <div className="w-full pt-4">
            {error && (
                <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm p-3 mb-4">
                    {error}
                </div>
            )}
            
            <div className="text-xs text-gray-500 dark:text-gray-400 mb-2 text-center">
                Google Sign-In {scriptLoaded ? 'Ready' : 'Loading...'}
            </div>
            
            <motion.button
                onClick={handleGoogleSignIn}
                disabled={loading || googleLoading}
                className="w-full bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 text-gray-700 dark:text-gray-300 
                         font-medium rounded-lg shadow-md hover:shadow-lg transition-all duration-200
                         flex items-center justify-center gap-3 px-4 py-3"
                whileHover={{ scale: loading || googleLoading ? 1 : 1.02 }}
                whileTap={{ scale: loading || googleLoading ? 1 : 0.98 }}
            >
                {googleLoading ? (
                    <>
                        <div className="w-4 h-4 border-2 border-gray-300 border-t-blue-500 rounded-full animate-spin"></div>
                        Connecting to Google...
                    </>
                ) : (
                    <>
                        <svg width="20" height="20" viewBox="0 0 24 24">
                            <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                            <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                            <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                            <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                        </svg>
                        Sign in with Google
                    </>
                )}
            </motion.button>
        </div>
    );
}
----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\TestGoogleButton.jsx -----
// Simple test component to verify Google Sign-In appears
import React from 'react';

export default function TestGoogleButton() {
    return (
        <div style={{ 
            backgroundColor: '#ffffff', 
            border: '1px solid #dadce0', 
            color: '#3c4043',
            padding: '10px 16px',
            borderRadius: '4px',
            fontSize: '14px',
            fontWeight: '500',
            cursor: 'pointer',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            gap: '8px',
            width: '100%',
            marginTop: '16px'
        }}>
            <svg width="20" height="20" viewBox="0 0 24 24">
                <path
                    fill="#4285F4"
                    d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                />
                <path
                    fill="#34A853"
                    d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                />
                <path
                    fill="#FBBC05"
                    d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"
                />
                <path
                    fill="#EA4335"
                    d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"
                />
            </svg>
            Sign in with Google (Test)
        </div>
    );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\UnlockMailbox.jsx -----
import { useState } from "react";
import { motion } from "framer-motion";
import { useAuth } from "../../context/AuthContext";
import { useNavigate } from "react-router-dom";

export default function UnlockMailbox() {
  const [password, setPassword] = useState("");
  const [error, setError] = useState("");
  const { unlockMailbox, loading, user } = useAuth();
  const navigate = useNavigate();

  const unlock = async (e) => {
    e.preventDefault();
    setError("");
    try {
      await unlockMailbox(password);
      navigate("/", { replace: true });
    } catch {
      setError("Invalid password");
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800">
      <motion.div 
        className="bg-white dark:bg-gray-800 p-8 rounded-2xl shadow-xl w-full max-w-sm"
        initial={{ opacity: 0, scale: 0.9 }}
        animate={{ opacity: 1, scale: 1 }}
        transition={{ duration: 0.5, ease: "easeOut" }}
      >
        <motion.h1 
          className="text-2xl font-bold text-center text-gray-900 dark:text-white mb-2"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.2 }}
        >
          Unlock Mailbox
        </motion.h1>
        <motion.p 
          className="text-sm text-gray-600 dark:text-gray-400 text-center mt-2"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
        >
          Welcome back, <strong>{user?.address}</strong>
        </motion.p>

        <motion.form 
          onSubmit={unlock} 
          className="mt-6 space-y-4"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.4 }}
        >
          <motion.div
            initial={{ opacity: 0, x: -20 }}
            animate={{ opacity: 1, x: 0 }}
            transition={{ delay: 0.5 }}
          >
            <input
              type="password"
              placeholder="Enter password to decrypt"
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              required
              disabled={loading}
              autoComplete="new-password"
            />
          </motion.div>

          {error && (
            <motion.div 
              className="text-red-600 dark:text-red-400 text-sm p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg"
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.3 }}
            >
              {error}
            </motion.div>
          )}

          <motion.button
            type="submit"
            disabled={loading}
            className="w-full bg-gradient-to-r from-indigo-600 to-indigo-700 hover:from-indigo-700 hover:to-indigo-800 disabled:from-gray-400 disabled:to-gray-500 
                     text-white font-semibold rounded-lg shadow-lg hover:shadow-xl disabled:shadow-none 
                     transition-all duration-300 disabled:cursor-not-allowed
                     flex items-center justify-center gap-2"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ delay: 0.6 }}
            whileHover={{ scale: loading ? 1 : 1.02 }}
            whileTap={{ scale: loading ? 1 : 0.98 }}
          >
            {loading ? (
              <>
                <motion.div 
                  className="w-4 h-4 border-2 border-white border-t-transparent rounded-full"
                  animate={{ rotate: 360 }}
                  transition={{ duration: 1, repeat: Infinity, ease: 'linear' }}
                />
                Decrypting‚Ä¶
              </>
            ) : (
              "Unlock Mailbox"
            )}
          </motion.button>
        </motion.form>

        <motion.p 
          className="text-xs text-gray-500 text-center mt-6"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          transition={{ delay: 0.7 }}
        >
          üîê Private keys are decrypted locally only
        </motion.p>
      </motion.div>
    </div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\common\ErrorBoundary.jsx -----
import React from 'react';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null, errorInfo: null };
  }

  static getDerivedStateFromError(error) {
    // Update state so the next render will show fallback UI
    return { hasError: true, error, errorInfo: { componentStack: error.toString() } };
  }

  componentDidCatch(error, errorInfo) {
    // Catch errors in any child components
    this.setState({
      hasError: true,
      error: error,
      errorInfo: errorInfo
    });
    
    // Log errors for debugging (only in development)
    if (import.meta.env.DEV) {
      console.error('ErrorBoundary caught an error:', error, errorInfo);
    }
  }

  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return (
        <div className="min-h-screen bg-red-50 flex items-center justify-center p-8">
          <div className="bg-white rounded-lg shadow-lg p-6 max-w-md">
            <h1 className="text-2xl font-bold text-red-600 mb-4">‚ö†Ô∏è Application Error</h1>
            <h2 className="text-lg font-semibold text-red-500 mb-2">Something went wrong</h2>
            <div className="mb-4">
              <p className="text-sm text-gray-600 mb-2"><strong>Error:</strong> {this.state.error?.toString() || 'Unknown error'}</p>
              {this.state.errorInfo && (
                <details className="text-xs text-gray-500 bg-gray-100 p-2 rounded">
                  <summary className="cursor-pointer font-semibold">Error Details</summary>
                  <pre className="whitespace-pre-wrap bg-gray-800 text-green-400 p-2 rounded text-xs">
                    {JSON.stringify(this.state.errorInfo, null, 2)}
                  </pre>
                </details>
              )}
            </div>
            
            <h3 className="text-lg font-semibold mb-2">Troubleshooting Steps:</h3>
            <ol className="list-decimal text-sm text-gray-600 space-y-1">
              <li>1. Check browser console for detailed error messages</li>
              <li>2. Try refreshing the page</li>
              <li>3. Clear browser cache and cookies</li>
              <li>4. Try disabling browser extensions temporarily</li>
              <li>5. Access the debug page: <code>http://localhost:5173/debug</code></li>
            </ol>
            
            <div className="mt-6 space-x-4">
              <button
                onClick={() => this.setState({ hasError: false, error: null, errorInfo: null })}
                className="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
              >
                Try Again
              </button>
              <button
                onClick={() => window.location.reload()}
                className="bg-gray-500 text-white px-4 py-2 rounded hover:bg-gray-600 ml-4"
              >
                Reload Page
              </button>
            </div>
          </div>
        </div>
      );
    }

    return this.props.children;
  }
}

export default ErrorBoundary;



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\common\Logo.jsx -----
import { motion } from 'framer-motion';
import CryptaMailIcon from '../ui/CryptaMailIcon';

export default function AuthLogo({ className = "" }) {
  return (
    <motion.div 
      className={`flex flex-col items-center justify-center mb-8 ${className}`}
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.6, ease: "easeOut" }}
    >
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5, delay: 0.2 }}
        className="mb-3"
      >
        <CryptaMailIcon size={48} animated={false} />
      </motion.div>
      
      <motion.h1 
        className="text-2xl font-bold text-gray-900 dark:text-white"
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5, delay: 0.3 }}
      >
        CryptaMail
      </motion.h1>
      
      <motion.p 
        className="text-sm text-gray-600 dark:text-gray-400 mt-1"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5, delay: 0.4 }}
      >
        End-to-End Encrypted Email
      </motion.p>
    </motion.div>
  );
}
import { useState, useEffect } from "react";
import { emailAPI } from "../../services/apiService";
import {
    decryptFile,
    decryptFilename,
    decryptAESKeyWithRSA,
    decryptChunk,
    base64ToArrayBuffer
} from "../../utils/cryptoUtils";

export default function AttachmentItem({ attachment: initialAttachment, userPrivateKey, isSender }) {
    const [attachment, setAttachment] = useState(initialAttachment);
    const [filename, setFilename] = useState("Decrypting name...");
    const [downloading, setDownloading] = useState(false);
    const [progress, setProgress] = useState(0);
    const [metadataLoading, setMetadataLoading] = useState(typeof initialAttachment === 'number' || !initialAttachment.encryptedFilename);

    useEffect(() => {
        const loadMetadata = async () => {
            if (typeof attachment === 'number' || !attachment.encryptedFilename) {
                try {
                    const id = typeof attachment === 'number' ? attachment : attachment.id;
                    const res = await emailAPI.getAttachmentMetadata(id);
                    setAttachment(res.data);
                    setMetadataLoading(false);
                } catch (e) {
                    console.error("Failed to load attachment metadata:", {
                        error: e.message,
                        status: e.response?.status,
                        data: e.response?.data
                    });
                    setFilename("Unavailable File");
                    setMetadataLoading(false);
                }
            }
        };
        loadMetadata();
    }, [attachment]);

    useEffect(() => {
        // Decrypt filename immediately for display
        const decryptName = async () => {
            if (metadataLoading || !attachment || !attachment.encryptedFilename) return;

            // If filenameIv is missing, use plain filename
            if (!attachment.filenameIv || attachment.filenameIv.trim() === '') {
                setFilename(attachment.encryptedFilename);
                return;
            }

            // Try multiple ways to get the encrypted key
            let encryptedKey = isSender ? attachment.encryptedKeySender : attachment.encryptedKeyRecipient;

            // Fallback: try the other key if the first one is missing
            if (!encryptedKey) {
                encryptedKey = isSender ? attachment.encryptedKeyRecipient : attachment.encryptedKeySender;
            }

            // Fallback: try any available key
            if (!encryptedKey) {
                encryptedKey = attachment.encryptedKeySender || attachment.encryptedKeyRecipient;
            }

            // Validate encryptedKey before attempting decryption
            if (!encryptedKey || typeof encryptedKey !== 'string' || encryptedKey.trim() === '') {
                console.error("Invalid encrypted key for filename decryption", {
                    isSender,
                    encryptedKeySender: attachment.encryptedKeySender ? "present" : "missing",
                    encryptedKeyRecipient: attachment.encryptedKeyRecipient ? "present" : "missing"
                });
                setFilename(attachment.encryptedFilename); // Fallback to stored filename
                return;
            }

            try {
                const name = await decryptFilename(
                    attachment.encryptedFilename,
                    attachment.filenameIv,
                    encryptedKey,
                    userPrivateKey
                );
                setFilename(name);
            } catch (e) {
                console.error("Name decryption failed", e);
                setFilename(attachment.encryptedFilename); // Fallback to stored filename
            }
        };
        decryptName();
    }, [attachment, userPrivateKey, isSender, metadataLoading]);

    const handleDownload = async () => {
        setDownloading(true);
        setProgress(0);

        try {
            // Debug: Log attachment structure
            console.log("Attachment data for download:", {
                id: attachment.id,
                encryptedKeySender: !!attachment.encryptedKeySender,
                encryptedKeyRecipient: !!attachment.encryptedKeyRecipient,
                isSender,
                totalChunks: attachment.totalChunks,
                encryptedBlob: !!attachment.encryptedBlob
            });

            // Try multiple ways to get the encrypted key
            let encryptedKey = isSender ? attachment.encryptedKeySender : attachment.encryptedKeyRecipient;

            // Fallback: try the other key if the first one is missing
            if (!encryptedKey) {
                encryptedKey = isSender ? attachment.encryptedKeyRecipient : attachment.encryptedKeySender;
            }

            // Fallback: try any available key
            if (!encryptedKey) {
                encryptedKey = attachment.encryptedKeySender || attachment.encryptedKeyRecipient;
            }

            // Validate encryptedKey before attempting decryption
            if (!encryptedKey || typeof encryptedKey !== 'string' || encryptedKey.trim() === '') {
                console.error("Invalid encrypted key for download", {
                    isSender,
                    encryptedKeySender: attachment.encryptedKeySender ? "present" : "missing",
                    encryptedKeyRecipient: attachment.encryptedKeyRecipient ? "present" : "missing",
                    allAttachmentKeys: Object.keys(attachment).filter(key => key.includes('encryptedKey'))
                });
                throw new Error("Invalid encrypted key: missing or empty");
            }

            console.log("üîì About to decrypt AES key", {
                encryptedKeyLength: encryptedKey.length,
                hasUserPrivateKey: !!userPrivateKey,
                userPrivateKeyType: userPrivateKey?.constructor?.name,
                userPrivateKeyTypeOf: typeof userPrivateKey,
                userPrivateKeyAlgorithm: userPrivateKey?.algorithm?.name,
                userPrivateKeyType2: userPrivateKey?.type,
                isSender,
                selectedKey: isSender ? 'encryptedKeySender' : 'encryptedKeyRecipient'
            });

            let aesKey;
            try {
                aesKey = await decryptAESKeyWithRSA(encryptedKey, userPrivateKey);
            } catch (keyDecryptError) {
                console.warn("‚ö†Ô∏è Primary key decryption failed, trying alternate key...", {
                    primaryError: keyDecryptError.message,
                    encryptedKeyLength: encryptedKey?.length,
                    userPrivateKeyAlgorithm: userPrivateKey?.algorithm?.name
                });

                // Try the alternate key
                const alternateKey = isSender ? attachment.encryptedKeyRecipient : attachment.encryptedKeySender;
                if (alternateKey && alternateKey !== encryptedKey) {
                    try {
                        console.log("üîÑ Trying alternate encrypted key...");
                        aesKey = await decryptAESKeyWithRSA(alternateKey, userPrivateKey);
                        console.log("‚úÖ Alternate key decrypted successfully");
                    } catch (alternateError) {
                        console.error("‚ùå Both key decryptions FAILED:", {
                            primaryError: keyDecryptError.message,
                            alternateError: alternateError.message,
                            userPrivateKeyValid: !!userPrivateKey,
                            keyType: userPrivateKey?.type,
                            algorithm: userPrivateKey?.algorithm?.name,
                            usages: userPrivateKey?.usages,
                            extractable: userPrivateKey?.extractable,
                            isSender,
                            primaryKeyUsed: isSender ? 'encryptedKeySender' : 'encryptedKeyRecipient',
                            alternateKeyUsed: isSender ? 'encryptedKeyRecipient' : 'encryptedKeySender'
                        });
                        throw new Error(`Cannot decrypt AES key: ${keyDecryptError.message}`);
                    }
                } else {
                    console.error("‚ùå AES key decryption FAILED (no alternate):", {
                        error: keyDecryptError.message,
                        errorStack: keyDecryptError.stack,
                        userPrivateKeyValid: !!userPrivateKey,
                        keyType: userPrivateKey?.type,
                        algorithm: userPrivateKey?.algorithm?.name,
                        usages: userPrivateKey?.usages,
                        extractable: userPrivateKey?.extractable,
                        availableKeys: {
                            hasSender: !!attachment.encryptedKeySender,
                            hasRecipient: !!attachment.encryptedKeyRecipient
                        }
                    });
                    throw new Error(`Cannot decrypt AES key: ${keyDecryptError.message}`);
                }
            }

            console.log("üîì AES key decrypted successfully", {
                aesKeyType: aesKey?.constructor?.name,
                aesKeyAlgorithm: aesKey?.algorithm?.name,
                aesKeyUsages: aesKey?.usages,
                aesKeyLength: aesKey?.algorithm?.length
            });

            const chunks = [];

            // Phase 2: Chunked
            if (attachment.totalChunks !== undefined && attachment.totalChunks !== null) {
                if (attachment.totalChunks === 0) {
                    // Empty file
                } else if (attachment.totalChunks > 0) {
                    for (let i = 0; i < attachment.totalChunks; i++) {
                        try {
                            const res = await emailAPI.getAttachmentChunk(attachment.id, i);
                            const encDataB64 = res.data.encryptedData;
                            const ivStr = res.data.iv;

                            if (!encDataB64 || typeof encDataB64 !== 'string' || encDataB64.trim() === '') {
                                throw new Error(`Invalid encrypted data for chunk ${i}`);
                            }
                            if (!ivStr || typeof ivStr !== 'string' || ivStr.trim() === '') {
                                throw new Error(`Invalid IV for chunk ${i}`);
                            }


                            console.log(`üì¶ Chunk ${i} received from server`, {
                                encDataLength: encDataB64.length, // Should be approx 6.6MB for 5MB chunk
                                ivLength: ivStr.length,
                                encDataStart: encDataB64.substring(0, 50),
                                ivStart: ivStr.substring(0, 50)
                            });

                            // Backend returns encryptedData and iv as base64 strings
                            const encryptedChunkBuffer = base64ToArrayBuffer(encDataB64);
                            const ivBuffer = base64ToArrayBuffer(ivStr);
                            const ivUint8 = new Uint8Array(ivBuffer);

                            console.log(`üîì About to decrypt chunk ${i}`, {
                                encryptedBufferLength: encryptedChunkBuffer.byteLength,
                                ivLength: ivUint8.length,
                                ivStart: Array.from(ivUint8.slice(0, 4)).map(b => b.toString(16)).join(' '),
                                aesKeyType: aesKey?.constructor?.name,
                                aesKeyAlgorithm: aesKey?.algorithm?.name
                            });

                            const decryptedAB = await decryptChunk(encryptedChunkBuffer, aesKey, ivUint8);
                            chunks.push(new Uint8Array(decryptedAB));

                            console.log(`‚úÖ Chunk ${i} decrypted successfully`, {
                                decryptedLength: decryptedAB.byteLength
                            });

                            setProgress(Math.round(((i + 1) / attachment.totalChunks) * 100));
                        } catch (chunkErr) {
                            console.error(`Error processing chunk ${i}:`, chunkErr);
                            throw chunkErr;
                        }
                    }
                }
            } else {
                // Phase 1: Legacy fallback
                if (!attachment.encryptedBlob) {
                    throw new Error("Legacy attachment missing 'encryptedBlob'.");
                }
                const decryptedAB = await decryptFile(
                    attachment.encryptedBlob,
                    attachment.iv,
                    encryptedKey,
                    userPrivateKey
                );
                chunks.push(new Uint8Array(decryptedAB));
                setProgress(100);
            }

            const blob = new Blob(chunks, { type: attachment.mimeType || "application/octet-stream" });

            // Removed empty check to allow 0-byte files

            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename; // Essential

            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
            setTimeout(() => window.URL.revokeObjectURL(url), 100);

        } catch (error) {
            console.error("Download failed", error);
            alert("Failed to download: " + error.message);
        } finally {
            setDownloading(false);
            setProgress(0);
        }
    };

    return (
        <div className="flex items-center justify-between p-3 border rounded-lg bg-slate-50 dark:bg-slate-800 dark:border-slate-700">
            <div className="flex items-center gap-3 overflow-hidden">
                <span className="text-2xl">
                    {attachment?.mimeType?.includes("image") ? "üñºÔ∏è" : "üìÑ"}
                </span>
                <div className="flex flex-col min-w-0">
                    <span className="text-sm font-medium truncate dark:text-slate-200" title={filename}>
                        {filename}
                    </span>
                    <span className="text-xs text-slate-500">
                        {attachment?.size ? (attachment.size / 1024).toFixed(1) + " KB" : "..."}
                    </span>
                </div>
            </div>
            <button
                onClick={handleDownload}
                disabled={downloading || metadataLoading || typeof attachment !== 'object'}
                className="ml-2 px-3 py-1 text-xs font-medium text-indigo-600 bg-indigo-50 hover:bg-indigo-100 rounded-full dark:bg-slate-700 dark:text-indigo-400 dark:hover:bg-slate-600 transition-colors"
            >
                {downloading ? "..." : "‚¨á"}
            </button>
        </div>
    );
}
import { motion } from 'framer-motion';
import { useEffect, useState } from 'react';

const AnimatedSectionBackground = ({ activeView, children }) => {
  const [backgroundStyle, setBackgroundStyle] = useState({});

  const viewConfigs = {
    inbox: {
      gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      particles: 'rgba(102, 126, 234, 0.1)',
      animation: 'float'
    },
    sent: {
      gradient: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
      particles: 'rgba(240, 147, 251, 0.1)',
      animation: 'pulse'
    },
    drafts: {
      gradient: 'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
      particles: 'rgba(79, 172, 254, 0.1)',
      animation: 'wave'
    },
    trash: {
      gradient: 'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
      particles: 'rgba(250, 112, 154, 0.1)',
      animation: 'shimmer'
    },
    spam: {
      gradient: 'linear-gradient(135deg, #30cfd0 0%, #330867 100%)',
      particles: 'rgba(48, 207, 208, 0.1)',
      animation: 'glitch'
    },
    settings: {
      gradient: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
      particles: 'rgba(168, 237, 234, 0.1)',
      animation: 'breathe'
    },
    default: {
      gradient: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      particles: 'rgba(99, 102, 241, 0.1)',
      animation: 'float'
    }
  };

  const currentConfig = viewConfigs[activeView] || viewConfigs.default;

  useEffect(() => {
    setBackgroundStyle({
      background: currentConfig.gradient,
      transition: 'all 0.8s ease-in-out'
    });
  }, [activeView, currentConfig]);

  const animationVariants = {
    float: {
      initial: { scale: 1, rotate: 0 },
      animate: { 
        scale: [1, 1.05, 1], 
        rotate: [0, 1, -1, 0],
        transition: { duration: 4, repeat: Infinity, ease: "easeInOut" }
      }
    },
    pulse: {
      initial: { scale: 1, opacity: 0.3 },
      animate: { 
        scale: [1, 1.1, 1], 
        opacity: [0.3, 0.6, 0.3],
        transition: { duration: 3, repeat: Infinity, ease: "easeInOut" }
      }
    },
    wave: {
      initial: { y: 0 },
      animate: { 
        y: [-10, 10, -10],
        transition: { duration: 6, repeat: Infinity, ease: "easeInOut" }
      }
    },
    shimmer: {
      initial: { backgroundPosition: '0% 50%' },
      animate: { 
        backgroundPosition: ['0% 50%', '100% 50%', '0% 50%'],
        transition: { duration: 8, repeat: Infinity, ease: "linear" }
      }
    },
    glitch: {
      initial: { x: 0 },
      animate: { 
        x: [0, -2, 2, -1, 1, 0],
        transition: { duration: 0.5, repeat: Infinity, repeatDelay: 3 }
      }
    },
    breathe: {
      initial: { scale: 1, opacity: 0.2 },
      animate: { 
        scale: [1, 1.02, 1],
        opacity: [0.2, 0.4, 0.2],
        transition: { duration: 5, repeat: Infinity, ease: "easeInOut" }
      }
    }
  };

  return (
    <div className="relative h-full overflow-hidden">
      {/* Animated gradient background */}
      <motion.div
        className="absolute inset-0 opacity-10"
        style={backgroundStyle}
        variants={animationVariants[currentConfig.animation]}
        initial="initial"
        animate="animate"
      />
      
      {/* Floating shapes */}
      <div className="absolute inset-0 pointer-events-none">
        {[...Array(6)].map((_, i) => (
          <motion.div
            key={i}
            className="absolute rounded-full opacity-20"
            style={{
              background: currentConfig.particles,
              width: Math.random() * 100 + 50,
              height: Math.random() * 100 + 50,
              left: `${Math.random() * 100}%`,
              top: `${Math.random() * 100}%`,
            }}
            animate={{
              y: [0, -30, 0],
              x: [0, Math.random() * 20 - 10, 0],
              scale: [1, Math.random() * 0.5 + 0.8, 1],
            }}
            transition={{
              duration: Math.random() * 5 + 5,
              repeat: Infinity,
              delay: Math.random() * 2,
              ease: "easeInOut"
            }}
          />
        ))}
      </div>

      {/* Content */}
      <div className="relative z-10 h-full">
        {children}
      </div>
    </div>
  );
};

export default AnimatedSectionBackground;






----- FILE: D:\CODES\ciphermailApp\frontend\src\components\ui\CryptaMailFavicon.jsx -----
import React from 'react';

export default function CryptaMailFavicon({ size = 32 }) {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 32 32"
      xmlns="http://www.w3.org/2000/svg"
    >
      <defs>
        <linearGradient id="faviconGradient" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stopColor="#3B82F6" />
          <stop offset="100%" stopColor="#06B6D4" />
        </linearGradient>
      </defs>

      {/* Simple envelope with lock */}
      <rect
        x="4"
        y="10"
        width="24"
        height="14"
        rx="2"
        fill="none"
        stroke="url(#faviconGradient)"
        strokeWidth="1.5"
      />
      
      {/* Envelope flap */}
      <path
        d="M4 12 L16 18 L28 12"
        fill="none"
        stroke="url(#faviconGradient)"
        strokeWidth="1.5"
        strokeLinecap="round"
      />
      
      {/* Lock icon */}
      <g transform="translate(16, 17)">
        <rect
          x="-2"
          y="-0.5"
          width="4"
          height="3"
          rx="0.5"
          fill="url(#faviconGradient)"
        />
        <path
          d="M-1.5,-0.5 A1.5,1.5 0 0,1 1.5,-0.5"
          fill="none"
          stroke="url(#faviconGradient)"
          strokeWidth="1"
          strokeLinecap="round"
        />
      </g>
    </svg>
  );
}
import { motion } from 'framer-motion';

const EmailSkeleton = () => {
  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="p-4 mb-2 rounded-xl bg-white dark:bg-slate-800 border border-transparent"
    >
      <div className="flex justify-between items-start mb-3">
        <div className="flex-1 min-w-0">
          <motion.div 
            className="h-4 bg-slate-200 dark:bg-slate-700 rounded w-32 mb-2"
            animate={{ opacity: [0.5, 1, 0.5] }}
            transition={{ duration: 1.5, repeat: Infinity }}
          />
        </div>
        <motion.div 
          className="h-3 bg-slate-200 dark:bg-slate-700 rounded w-16 ml-2"
          animate={{ opacity: [0.5, 1, 0.5] }}
          transition={{ duration: 1.5, repeat: Infinity, delay: 0.2 }}
        />
      </div>
      <motion.div 
        className="h-3 bg-slate-200 dark:bg-slate-700 rounded w-3/4"
        animate={{ opacity: [0.5, 1, 0.5] }}
        transition={{ duration: 1.5, repeat: Infinity, delay: 0.4 }}
      />
    </motion.div>
  );
};

const LoadingSkeleton = ({ count = 5 }) => {
  return (
    <div className="p-2">
      {[...Array(count)].map((_, i) => (
        <EmailSkeleton key={i} />
      ))}
    </div>
  );
};

export default LoadingSkeleton;



/**
 * Environment Configuration & Validation
 * Validates that all required environment variables are set correctly
 * Enforces HTTPS in production
 */

const requiredEnvVars = {
  VITE_GOOGLE_CLIENT_ID: 'Google OAuth Client ID',
  VITE_API_BASE_URL: 'Backend API base URL',
};

const optionalEnvVars = {
  VITE_GOOGLE_REDIRECT_URI: 'Google OAuth redirect URI',
};

/**
 * Validate environment configuration
 * @throws {Error} if required environment variables are missing or invalid
 */
export function validateEnvironment() {
  const missingVars = [];

  // Check required environment variables
  for (const [key, description] of Object.entries(requiredEnvVars)) {
    const value = import.meta.env[key];

    if (!value) {
      missingVars.push(`${key} (${description})`);
    }

    // Check for placeholder values in production
    if (import.meta.env.PROD && value && value.includes('your_')) {
      missingVars.push(`${key} is still a placeholder value (${description})`);
    }
  }

  if (missingVars.length > 0) {
    const errorMsg = `Missing or invalid environment variables:\n${missingVars.map(v => `  - ${v}`).join('\n')}`;
    console.error('‚ùå Environment Configuration Error:', errorMsg);
    throw new Error(errorMsg);
  }

  // Validate API URL format
  const apiUrl = import.meta.env.VITE_API_BASE_URL;
  try {
    new URL(apiUrl);
  } catch (e) {
    throw new Error(`Invalid API URL format: ${apiUrl}`);
  }

  // Enforce HTTPS in production
  if (import.meta.env.PROD) {
    const prodEnforceHttps = (url) => {
      const urlObj = new URL(url);
      if (urlObj.protocol !== 'https:') {
        throw new Error(`HTTPS is required in production. Got: ${urlObj.protocol}//${urlObj.host}`);
      }
      return true;
    };

    try {
      prodEnforceHttps(apiUrl);
      const redirectUri = import.meta.env.VITE_GOOGLE_REDIRECT_URI;
      if (redirectUri) {
        prodEnforceHttps(redirectUri);
      }
    } catch (e) {
      console.error('‚ùå HTTPS Validation Error:', e.message);
      throw e;
    }
  }

  // Log successful validation in development
  if (import.meta.env.DEV) {
    console.log('‚úÖ Environment configuration validated successfully');
    console.log('  - API Base URL:', apiUrl);
    console.log('  - Google OAuth configured');
  }
}

/**
 * Get environment configuration
 */
export const environment = {
  isDevelopment: import.meta.env.DEV,
  isProduction: import.meta.env.PROD,
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL,
  googleClientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
  googleRedirectUri: import.meta.env.VITE_GOOGLE_REDIRECT_URI || 'http://localhost:5173',
};

/**
 * Auto-redirect HTTP to HTTPS in production
 */
export function enforceHttpsRedirect() {
  if (import.meta.env.PROD && window.location.protocol !== 'https:') {
    const httpsUrl = window.location.href.replace(/^http:/, 'https:');
    window.location.href = httpsUrl;
  }
}

export default environment;




----- FILE: D:\CODES\ciphermailApp\frontend\src\context\AuthContext.jsx -----
import React, { createContext, useContext, useState, useEffect } from "react";
import { authAPI } from "../services/apiService";
import SecureStorage from "../utils/secureStorage";
import SecurityLogger from "../utils/securityLogger";
import { checkLoginRateLimit } from "../utils/rateLimiter";
import {
  generateRSAKeyPair,
  exportPublicKey,
  exportPrivateKey,
  encryptPrivateKey,
  importPrivateKey,
  decryptPrivateKey,
} from "../utils/cryptoUtils";

const AuthContext = createContext(null);

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) {
    throw new Error("useAuth must be used within AuthProvider");
  }
  return ctx;
}

export function AuthProvider({ children }) {
  // ‚ö†Ô∏è SECURITY: Use SecureStorage (cookies) instead of localStorage for tokens
  const [token, setToken] = useState(() => SecureStorage.getToken("token"));
  const [user, setUser] = useState(() => {
    try {
      const raw = localStorage.getItem("user");
      return raw ? JSON.parse(raw) : null;
    } catch (e) {
      if (import.meta.env.DEV) console.error('Failed to parse user from localStorage', e);
      localStorage.removeItem("user");
      return null;
    }
  });
  const [encryptedPrivateKey, setEncryptedPrivateKey] = useState(() => {
    try {
      const raw = localStorage.getItem("encryptedPrivateKey");
      return raw ? JSON.parse(raw) : null;
    } catch (e) {
      if (import.meta.env.DEV) console.error('Failed to parse encryptedPrivateKey from localStorage', e);
      localStorage.removeItem("encryptedPrivateKey");
      return null;
    }
  });
  const [privateKey, setPrivateKey] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState("");
  const [initialized, setInitialized] = useState(false);
  const [sessionUnlocked, setSessionUnlocked] = useState(() => {
    // Check if session was recently unlocked (within last 5 minutes)
    const lastUnlock = sessionStorage.getItem('lastUnlockTime');
    if (lastUnlock) {
      const timeSinceUnlock = Date.now() - parseInt(lastUnlock, 10);
      return timeSinceUnlock < 5 * 60 * 1000; // 5 minutes
    }
    return false;
  });
  // Store the decrypted private key temporarily during this session
  const [sessionPrivateKey, setSessionPrivateKey] = useState(null);

  const isAuthenticated = !!token && !!user;
  // If we don't have the private key, we are locked regardless of session timer
  // The session timer is only useful if we were persisting the key (which we aren't currently for security)
  const isLocked = isAuthenticated && !privateKey && !!encryptedPrivateKey;

  // Initialize auth state on mount
  useEffect(() => {
    // On page load, check if session was recently unlocked
    // If yes, don't force re-lock. If no, clear private key.
    if (!sessionUnlocked) {
      setPrivateKey(null);
    }

    if (import.meta.env.DEV) {
      console.debug('üîê Auth initialization:', {
        hasToken: !!token,
        hasUser: !!user,
        hasEncryptedKey: !!encryptedPrivateKey,
        hasPrivateKey: !!privateKey,
        sessionUnlocked,
        isAuthenticated,
        isLocked
      });
    }

    // Delay initialization to ensure all state is settled
    setTimeout(() => {
      setInitialized(true);
    }, 100);
  }, []); // Only run on mount

  // Log state changes only in development
  useEffect(() => {
    if (initialized && import.meta.env.DEV) {
      console.debug('üîê Auth state changed:', {
        isAuthenticated,
        isLocked,
        hasEncryptedKey: !!encryptedPrivateKey,
        hasPrivateKey: !!privateKey
      });
    }
  }, [isAuthenticated, isLocked, encryptedPrivateKey, privateKey, initialized]);

  // LOGIN
  const login = async (username, password) => {
    setLoading(true);
    setError("");
    try {
      if (!username || !password) {
        throw new Error("Username and password are required");
      }

      // ‚ö†Ô∏è SECURITY: Check rate limiting before attempting login
      try {
        checkLoginRateLimit(username);
      } catch (rateLimitError) {
        SecurityLogger.logRateLimitExceeded('login', username, rateLimitError.waitSeconds);
        setError(rateLimitError.message);
        setLoading(false);
        throw rateLimitError;
      }

      const response = await authAPI.login({ username, password });

      if (!response?.data) {
        throw new Error("Invalid response from server");
      }

      const {
        token,
        userId,
        username: u,
        address,
        publicKey,
        encryptedPrivateKey,
      } = response.data;

      if (!token || !userId) {
        throw new Error("Missing required auth data from server");
      }

      const userDto = {
        id: userId,
        username: u || username,
        address,
        publicKey,
        loading: false,
        error: "",
        isAuthenticated: true,
        isLocked: false, // Will auto-unlock with password
      };

      setUser(userDto);
      setEncryptedPrivateKey(encryptedPrivateKey || null);
      setToken(token);

      // ‚ö†Ô∏è SECURITY: Store token in secure cookie instead of localStorage
      SecureStorage.setToken("token", token, 24);

      localStorage.setItem("user", JSON.stringify(userDto));
      if (encryptedPrivateKey) {
        localStorage.setItem("encryptedPrivateKey", JSON.stringify(encryptedPrivateKey));

        // Automatically decrypt private key using login password
        try {
          const privateKeyB64 = await decryptPrivateKey(encryptedPrivateKey, password);
          const privateKeyObj = await importPrivateKey(privateKeyB64);
          setPrivateKey(privateKeyObj);
          setSessionPrivateKey(privateKeyB64);
          setSessionUnlocked(true);
          sessionStorage.setItem('lastUnlockTime', Date.now().toString());
        } catch (decryptError) {
          if (import.meta.env.DEV) console.warn("Auto-decrypt failed, user will see unlock page:", decryptError.message);
          setPrivateKey(null);
        }
      } else {
        setPrivateKey(null);
      }

      // Log successful login
      setLoading(false);
      return response;
    } catch (err) {
      console.error("Login error:", err);
      setError(err.message || "Login failed");
      setLoading(false);
      throw err;
    }
  };

  // REGISTER
  const register = async (username, password, dateOfBirth) => {
    setLoading(true);
    setError("");
    try {
      // Generate RSA key pair for the user
      const { publicKey, privateKey } = await generateRSAKeyPair();
      const publicKeyB64 = await exportPublicKey(publicKey);
      const privateKeyB64 = await exportPrivateKey(privateKey);

      // Use user's password to encrypt the private key
      const encrypted = await encryptPrivateKey(privateKeyB64, password);

      const response = await authAPI.register({
        username,
        password,
        dateOfBirth,
        publicKey: publicKeyB64,
        encryptedPrivateKey: encrypted,
      });

      const {
        token,
        userId,
        address,
        encryptedPrivateKey: encryptedKey,
      } = response.data;

      const userDto = {
        id: userId,
        username,
        address,
        publicKey: publicKeyB64,
        loading: false,
        error: "",
        isAuthenticated: true,
        isLocked: false, // Will auto-unlock with password just used
      };

      setUser(userDto);
      setEncryptedPrivateKey(encryptedKey);
      // Store the private key we just generated in this session
      setPrivateKey(privateKey);
      setSessionPrivateKey(privateKeyB64);
      setSessionUnlocked(true);
      sessionStorage.setItem('lastUnlockTime', Date.now().toString());
      setToken(token);
      localStorage.setItem("token", token);
      localStorage.setItem("user", JSON.stringify(userDto));
      localStorage.setItem("encryptedPrivateKey", JSON.stringify(encryptedKey));
      console.log('üìù Registration: saved encrypted key:', encryptedKey);

      setLoading(false);
      return response;
    } catch (err) {
      console.error("Registration error:", err);
      setError(err.message || "Registration failed");
      setLoading(false);
      throw err;
    }
  };

  // UNLOCK MAILBOX
  const unlockMailbox = async (password) => {
    setLoading(true);
    setError("");

    if (!encryptedPrivateKey) {
      throw new Error("No encrypted private key found");
    }

    try {
      if (import.meta.env.DEV) {
        console.log('üîì Unlock attempt:', {
          hasEncryptedKey: !!encryptedPrivateKey,
          encryptedKeyFields: encryptedPrivateKey ? Object.keys(encryptedPrivateKey) : null
        });
      }

      // Decrypt private key using password
      const privateKeyB64 = await decryptPrivateKey(encryptedPrivateKey, password);
      if (import.meta.env.DEV) console.log('üîì Decryption successful, got base64 string length:', privateKeyB64?.length);

      // Import the decrypted private key to get CryptoKey object
      let privateKey;
      try {
        privateKey = await importPrivateKey(privateKeyB64);
        if (import.meta.env.DEV) console.log('üîì Import successful, key type:', privateKey?.type);
      } catch (importError) {
        if (import.meta.env.DEV) console.error('üîì Import failed:', importError);
        throw new Error('Failed to import decrypted private key: ' + importError.message);
      }

      // Use the existing public key from user object (no need to re-export)
      const publicKey = user.publicKey;
      if (import.meta.env.DEV) console.log('üîì Using existing public key from user object');

      // Update user state
      const updatedUser = {
        ...user,
        isLocked: false,
        publicKey: publicKey,
      };

      setUser(updatedUser);
      setPrivateKey(privateKey);
      // KEEP encryptedPrivateKey in storage for page refresh scenario
      // Mark session as unlocked with timestamp
      setSessionUnlocked(true);
      sessionStorage.setItem('lastUnlockTime', Date.now().toString());
      localStorage.setItem("user", JSON.stringify(updatedUser));

      return { success: true };
    } catch (err) {
      if (import.meta.env.DEV) {
        console.error("üîì Mailbox unlock error:", err);
        console.error("üîì Encrypted key data:", encryptedPrivateKey);
      }
      setError(err.message || "Failed to unlock mailbox");
      setLoading(false);
      throw err;
    }
  };

  // GOOGLE SIGN IN
  const googleSignIn = async (googleUserData, password = '') => {
    setLoading(true);
    setError("");
    try {
      // Call the Google login API
      const response = await authAPI.googleLogin({
        googleToken: googleUserData.token,
      });

      const {
        token,
        userId,
        username: u,
        address,
        publicKey,
        encryptedPrivateKey,
      } = response.data;

      const userDto = {
        id: userId,
        username: u,
        address,
        publicKey,
        email: googleUserData.email,
        name: googleUserData.name,
        imageUrl: googleUserData.imageUrl,
        loading: false,
        error: "",
        isAuthenticated: true,
        isLocked: false,
      };

      setUser(userDto);
      setEncryptedPrivateKey(encryptedPrivateKey);
      setPrivateKey(null); // Will be set after decryption if needed
      setToken(token);

      // ‚ö†Ô∏è SECURITY: Store token in secure cookie instead of localStorage
      SecureStorage.setToken("token", token, 24);

      localStorage.setItem("user", JSON.stringify(userDto));
      if (encryptedPrivateKey) {
        localStorage.setItem("encryptedPrivateKey", JSON.stringify(encryptedPrivateKey));
      }

      // Log successful login
      SecurityLogger.logSuccessfulLogin(userId, u);

      return response;
    } catch (err) {
      if (import.meta.env.DEV) console.error("Google sign-in error:", err);

      // Log failed login
      SecurityLogger.logFailedLogin(googleUserData?.email || 'unknown', 'google_signin_failed');

      setError(err.message || "Google sign-in failed");
      setLoading(false);
      throw err;
    }
  };

  // LOGOUT
  const logout = () => {
    setUser(null);
    setToken(null);
    setPrivateKey(null);
    setEncryptedPrivateKey(null);
    setSessionUnlocked(false);

    // ‚ö†Ô∏è SECURITY: Clear secure cookies instead of localStorage
    SecureStorage.removeToken("token");
    SecureStorage.removeToken("refreshToken");

    localStorage.removeItem("user");
    localStorage.removeItem("encryptedPrivateKey");
    sessionStorage.removeItem('lastUnlockTime');

    // Log logout event
    SecurityLogger.logLogout(user?.id || 'unknown', 'user_initiated');
  };

  // CLEAR SESSION (for account deletion)
  const clearSession = () => {
    logout(); // Reuse logout logic
    // Additional cleanup if needed
  };

  // CONTEXT VALUE
  const value = {
    user,
    token,
    privateKey,
    encryptedPrivateKey,
    loading,
    error,
    isAuthenticated,
    isLocked,
    initialized,
    login,
    register,
    unlockMailbox,
    logout,
    clearSession,
    googleSignIn,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}
----- FILE: D:\CODES\ciphermailApp\frontend\src\hooks\useIdleTimer.js -----
/**
 * useIdleTimer Hook
 * Detects user inactivity and triggers auto-logout
 * Monitors: mousedown, mousemove, keypress, scroll, touchstart
 * Timeout: 15 minutes (900000ms)
 */

import { useEffect, useRef, useCallback } from 'react';

export function useIdleTimer(onIdle, timeoutMs = 15 * 60 * 1000) {
  const timeoutIdRef = useRef(null);
  const isIdleRef = useRef(false);

  /**
   * Reset the idle timer
   */
  const resetTimer = useCallback(() => {
    if (isIdleRef.current) {
      if (import.meta.env.DEV) {
        console.log('‚è±Ô∏è User activity detected, resetting idle timer');
      }
      isIdleRef.current = false;
    }

    if (timeoutIdRef.current) {
      clearTimeout(timeoutIdRef.current);
    }

    // Set new timeout
    timeoutIdRef.current = setTimeout(() => {
      if (import.meta.env.DEV) {
        console.warn('‚è±Ô∏è Idle timeout reached, triggering logout');
      }
      isIdleRef.current = true;
      onIdle();
    }, timeoutMs);
  }, [timeoutMs, onIdle]);

  /**
   * Activity event handler
   */
  const handleActivity = useCallback(() => {
    resetTimer();
  }, [resetTimer]);

  /**
   * Set up event listeners
   */
  useEffect(() => {
    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];

    events.forEach((event) => {
      document.addEventListener(event, handleActivity);
    });

    // Initial timer setup
    resetTimer();

    return () => {
      // Clean up event listeners
      events.forEach((event) => {
        document.removeEventListener(event, handleActivity);
      });

      // Clear timeout
      if (timeoutIdRef.current) {
        clearTimeout(timeoutIdRef.current);
      }
    };
  }, [handleActivity, resetTimer]);

  /**
   * Manually reset the idle timer (for testing or explicit reset)
   */
  const manualReset = useCallback(() => {
    if (import.meta.env.DEV) {
      console.log('‚è±Ô∏è Idle timer manually reset');
    }
    resetTimer();
  }, [resetTimer]);

  return {
    resetTimer: manualReset,
    isIdle: () => isIdleRef.current,
  };
}

export default useIdleTimer;




----- FILE: D:\CODES\ciphermailApp\frontend\src\services\apiService.js -----
import axios from 'axios';
import SecureStorage from '../utils/secureStorage';

const API_BASE_URL = import.meta.env.VITE_API_BASE_URL || "http://localhost:8080/api";

// Create axios instance with default config
const api = axios.create({
    baseURL: API_BASE_URL,
    headers: {
        'Content-Type': 'application/json',
    },
});

// Add JWT token to requests
api.interceptors.request.use((config) => {
  // ‚ö†Ô∏è SECURITY: Use SecureStorage instead of localStorage for token
  const token = SecureStorage.getToken("token");

  if (token) {
    // Basic token format validation
    try {
      if (token.split('.').length === 3) {
        config.headers = config.headers ?? {};
        config.headers.Authorization = `Bearer ${token}`;
      } else if (import.meta.env.DEV) {
        console.warn('Invalid JWT token format');
      }
    } catch (e) {
      if (import.meta.env.DEV) console.error('JWT token validation error', e);
    }
  }

  return config;
});

// Add response interceptor for consistent error handling
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Clear all auth data
      // ‚ö†Ô∏è SECURITY: Clear secure cookies instead of localStorage
      SecureStorage.removeToken("token");
      SecureStorage.removeToken("refreshToken");
      localStorage.removeItem("user");
      localStorage.removeItem("encryptedPrivateKey");
      sessionStorage.removeItem('lastUnlockTime');
      // Dispatch an event that a React component can listen for to handle the redirect.
      window.dispatchEvent(new Event('unauthorized'));
    }
    return Promise.reject(error);
  }
);


// Authentication endpoints
export const authAPI = {
    /**
     * Register new user with encrypted private key
     * @param {Object} data - Registration data
     * @param {string} data.username - Username (local part)
     * @param {string} data.password - User password
     * @param {string} data.publicKey - Base64 public key
     * @param {Object} data.encryptedPrivateKey - Encrypted private key blob
     */
    register: (data) => {
        return api.post('/auth/register', data);
    },

    /**
     * Login with username and password
     * @param {Object} credentials - Login credentials
     * @param {string} credentials.username - Username
     * @param {string} credentials.password - Password
     */
login: (credentials) => {
        return api.post('/auth/login', credentials);
    },

    /**
     * Google OAuth registration
     * @param {Object} data - Google registration data
     * @param {string} data.username - Generated username
     * @param {string} data.email - Google email
     * @param {string} data.name - Google display name
     * @param {string} data.googleId - Google user ID
     * @param {string} data.dateOfBirth - Date of birth (if available)
     * @param {string} data.publicKey - Base64 public key
     * @param {Object} data.encryptedPrivateKey - Encrypted private key blob
     * @param {string} data.googleToken - Google OAuth token
     */
    googleRegister: (data) => {
        return api.post('/auth/google-register', data);
    },

    /**
     * Google OAuth login
     * @param {Object} data - Google login data
     * @param {string} data.googleToken - Google OAuth token
     */
    googleLogin: (data) => {
        return api.post('/auth/google-login', data);
    },
};

// User endpoints
export const userAPI = {
    /**
     * Get user's public key by username or address
     * @param {string} usernameOrAddress - Username (e.g., "alice") or full address (e.g., "alice@smail.in")
     */
    getPublicKey: (usernameOrAddress) => {
        // If it contains @, treat as address; otherwise as username
        const paramKey = usernameOrAddress.includes('@') ? 'address' : 'username';
        return api.get('/users/public-key', { params: { [paramKey]: usernameOrAddress } });
    },
    searchUsers: (query) => api.get(`/users/search?query=${query}`),
    updateProfile: (data) => api.put("/users/profile", data),
    getStorageUsage: () => api.get("/users/storage"),
    deleteAccount: (password) => api.delete("/users/account", { data: { password } }),
};

// Email endpoints
export const emailAPI = {
    getInbox: () => {
        return api.get('/emails/inbox');
    },
    getSent: () => {
        return api.get('/emails/sent');
    },
getTrash: () => {
        return api.get('/emails/trash');
    },
    getSpam: () => {
        return api.get('/emails/spam');
    },
    getEmail: (id) => {
        return api.get(`/emails/${id}`);
    },
    saveDraft: (emailData) => {
        return api.post('/emails/drafts', emailData);
    },
    getDrafts: () => api.get("/emails/drafts"),
    deleteDraft: (id) => api.delete(`/emails/drafts/${id}`),
    deleteEmail: (id) => api.delete(`/emails/${id}`),
    /**
     * Send encrypted email
     * @param {Object} emailData - Encrypted email data
     * @param {string} emailData.toUsername - Recipient username
     * @param {string} emailData.encryptedSubject - Base64 encrypted subject
     * @param {string} emailData.subjectIv - Base64 IV for subject
     * @param {string} emailData.encryptedBody - Base64 encrypted body
     * @param {string} emailData.bodyIv - Base64 IV for body
     * @param {string} emailData.encryptedSymmetricKey - Wrapped AES key for recipient
     * @param {string} emailData.senderEncryptedSymmetricKey - Wrapped AES key for sender
     */
    sendEmail: (emailData) => {
        return api.post('/emails/send', emailData);
    },
    markAsRead: (id) => {
        return api.patch(`/emails/${id}/read`);
    },
    permanentlyDeleteEmail: (id) => {
        return api.delete(`/emails/${id}/permanent`);
    },
    emptyTrash: () => {
        return api.delete('/emails/trash/empty');
    },
    markSpam: (id) => {
        return api.patch(`/emails/${id}/spam`);
    },
    markNotSpam: (id) => {
        return api.patch(`/emails/${id}/not-spam`);
    },
    restoreEmail: (id) => {
        return api.patch(`/emails/${id}/restore`);
    },
    toggleStar: (id, isStarred) => {
        return api.patch(`/emails/${id}/star`, { isStarred });
    },
    toggleImportant: (id, isImportant) => {
        return api.patch(`/emails/${id}/important`, { isImportant });
    },
    // Attachments (Phase 2 + Legacy Compat where applicable)
    initAttachment: (data) => api.post('/attachments/init', data),
    uploadChunk: (id, data) => api.post(`/attachments/${id}/chunk`, data),
    getAttachmentStatus: (id) => api.get(`/attachments/${id}/status`),
    completeAttachment: (id) => api.post(`/attachments/${id}/complete`),
    getAttachmentChunk: (id, index) => api.get(`/attachments/${id}/chunks/${index}`),
    getAttachmentMetadata: (id) => api.get(`/attachments/${id}`),
};

export default api;



----- FILE: D:\CODES\ciphermailApp\frontend\src\services\authService.js -----
import { authAPI } from './apiService';
import { generateRSAKeyPair, encryptPrivateKey, decryptPrivateKey } from '../utils/cryptoUtils';

/**
 * Authentication service for user registration and login.
 * Handles key generation and secure storage.
 */

/**
 * Register a new user.
 * Generates RSA key pair and sends public key to server.
 * Encrypts and stores private key locally.
 */
export async function register(email, password) {
    try {
        // Generate RSA key pair
        const { publicKey, privateKey } = await generateRSAKeyPair();

        // Register user with backend
        const response = await authAPI.register(email, password, publicKey);

        // Store token
        localStorage.setItem('token', response.data.token);
        localStorage.setItem('userEmail', response.data.email);
        localStorage.setItem('userId', response.data.userId);
        localStorage.setItem('publicKey', publicKey);

        // Encrypt and store private key
        const encryptedPrivateKey = await encryptPrivateKey(privateKey, password);
        localStorage.setItem('encryptedPrivateKey', encryptedPrivateKey);

        return response.data;
    } catch (error) {
        throw new Error(error.response?.data || 'Registration failed');
    }
}

/**
 * Login existing user.
 * Retrieves and decrypts private key.
 */
export async function login(email, password) {
    try {
        // Login user
        const response = await authAPI.login(email, password);

        // Store token
        localStorage.setItem('token', response.data.token);
        localStorage.setItem('userEmail', response.data.email);
        localStorage.setItem('userId', response.data.userId);
        if (response.data.publicKey) {
            localStorage.setItem('publicKey', response.data.publicKey);
        }

        // Check if we have encrypted private key
        const encryptedPrivateKey = localStorage.getItem('encryptedPrivateKey');

        if (!encryptedPrivateKey) {
            // First login on this device - generate keys
            const { publicKey, privateKey } = await generateRSAKeyPair();
            const encrypted = await encryptPrivateKey(privateKey, password);
            localStorage.setItem('encryptedPrivateKey', encrypted);
        } else {
            // Verify we can decrypt the key (validates password)
            try {
                await decryptPrivateKey(encryptedPrivateKey, password);
            } catch (e) {
                throw new Error('Failed to decrypt private key. Wrong password?');
            }
        }

        return response.data;
    } catch (error) {
        throw new Error(error.response?.data || error.message || 'Login failed');
    }
}

/**
 * Logout user.
 */
export function logout() {
    localStorage.removeItem('token');
    localStorage.removeItem('userEmail');
    localStorage.removeItem('userId');
    localStorage.removeItem('publicKey');
    // Note: We keep encryptedPrivateKey for future logins
}

/**
 * Check if user is authenticated.
 */
export function isAuthenticated() {
    return !!localStorage.getItem('token');
}

/**
 * Get current user info.
 */
export function getCurrentUser() {
    return {
        email: localStorage.getItem('userEmail'),
        userId: localStorage.getItem('userId'),
    };
}

/**
 * Get decrypted private key.
 * Requires user's password.
 */
export async function getPrivateKey(password) {
    const encryptedPrivateKey = localStorage.getItem('encryptedPrivateKey');
    if (!encryptedPrivateKey) {
        throw new Error('No private key found');
    }
    return await decryptPrivateKey(encryptedPrivateKey, password);
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\services\emailService.js -----
/**
 * Email Service for End-to-End Encrypted Emails
 * 
 * Handles:
 * - Sending encrypted emails (hybrid encryption)
 * - Decrypting received emails
 * - Fetching inbox and sent emails
 * 
 * @module emailService
 */

import { emailAPI, userAPI } from './apiService';
import {
    encryptEmail,
    decryptEmail,
    importPublicKey,
} from '../utils/cryptoUtils';
import { parseAppEmail } from '../utils/addressUtils';

// ============================================================================
// SEND EMAIL
// ============================================================================

/**
 * Send an end-to-end encrypted email
 * 
 * Process:
 * 1. Parse recipient address to get username
 * 2. Fetch recipient's public key
 * 3. Encrypt subject and body with hybrid encryption
 * 4. Send encrypted data to backend
 * 
 * @param {Object} params - Email parameters
 * @param {string} params.toAddress - Recipient address (e.g., "bob@smail.in")
 * @param {string} params.subject - Email subject (plaintext)
 * @param {string} params.body - Email body (plaintext)
 * @param {string} params.senderPublicKeyB64 - Sender's public key (Base64)
 * @param {Array<number>} params.attachmentIds - List of attachment IDs (optional)
 * @returns {Promise<Object>} Backend response
 */
export async function sendEncryptedEmail({ toAddress, subject, body, senderPublicKeyB64, attachmentIds = [] }) {
    try {
        // Parse recipient address to get username
        const recipientUsername = parseAppEmail(toAddress);

        // Fetch recipient's public key
        const response = await userAPI.getPublicKey(recipientUsername);
        const recipientPublicKeyB64 = response.data.publicKey;

        if (!recipientPublicKeyB64) {
            throw new Error(`User ${toAddress} not found`);
        }

        // Import public keys
        const recipientPublicKey = await importPublicKey(recipientPublicKeyB64);
        const senderPublicKey = await importPublicKey(senderPublicKeyB64);

        // Encrypt email for both sender and recipient
        const encrypted = await encryptEmail(subject, body, recipientPublicKey, senderPublicKey);

// Send to backend
        const result = await emailAPI.sendEmail({
            toUsername: recipientUsername,
            encryptedSubject: encrypted.encryptedSubject,
            subjectIv: encrypted.subjectIv,
            encryptedBody: encrypted.encryptedBody,
            bodyIv: encrypted.bodyIv,
            encryptedSymmetricKey: encrypted.encryptedSymmetricKey,
            senderEncryptedSymmetricKey: encrypted.senderEncryptedSymmetricKey,
            attachmentIds: attachmentIds,
        });

        return result;

    } catch (error) {
        console.error('Failed to send encrypted email:', error);
        throw error;
    }
}

// ============================================================================
// DECRYPT EMAIL
// ============================================================================

/**
 * Decrypt an email with user's private key
 * 
 * @param {Object} email - Encrypted email from backend
 * @param {string} email.encryptedSubject - Base64 ciphertext
 * @param {string} email.subjectIv - Base64 IV
 * @param {string} email.encryptedBody - Base64 ciphertext
 * @param {string} email.bodyIv - Base64 IV
 * @param {string} email.encryptedSymmetricKey - Wrapped AES key for recipient
 * @param {string} email.senderEncryptedSymmetricKey - Wrapped AES key for sender
 * @param {Array<number>} email.attachmentIds - Array of attachment IDs
 * @param {CryptoKey} userPrivateKey - User's RSA private key
 * @param {string} viewType - "inbox" or "sent"
 * @returns {Promise<{subject: string, body: string, attachments: Array}>} Decrypted content
 */
export async function decryptEmailMessage(email, userPrivateKey, viewType) {
    try {
        // Validate inputs
        if (!email) {
            throw new Error('Email object is null or undefined');
        }

        if (!userPrivateKey) {
            throw new Error('User private key is required for decryption');
        }

        console.log("üîì Starting email decryption:", {
            emailId: email.id,
            hasEncryptedSubject: !!email.encryptedSubject,
            hasSubjectIv: !!email.subjectIv,
            hasEncryptedBody: !!email.encryptedBody,
            hasBodyIv: !!email.bodyIv,
            hasEncryptedSymmetricKey: !!email.encryptedSymmetricKey,
            hasSenderEncryptedSymmetricKey: !!email.senderEncryptedSymmetricKey,
            viewType,
            isSender: email.isSender,
            privateKeyType: userPrivateKey?.type,
            privateKeyAlgorithm: userPrivateKey?.algorithm?.name
        });

        // Determine which encrypted key to use
        const encryptedSymmetricKey = (viewType === 'sent' || email.isSender)
            ? email.senderEncryptedSymmetricKey
            : email.encryptedSymmetricKey;

        if (!encryptedSymmetricKey) {
            if (viewType === 'sent' || email.isSender) {
                throw new Error(
                    'This email was sent before sender decryption was enabled and cannot be viewed.'
                );
            } else {
                throw new Error('Missing encryption key for this email.');
            }
        }

        // Validate required fields
        if (!email.encryptedSubject || !email.subjectIv) {
            throw new Error('Missing encrypted subject or IV');
        }
        if (!email.encryptedBody || !email.bodyIv) {
            throw new Error('Missing encrypted body or IV');
        }

        console.log("üîê About to decrypt subject and body:", {
            encryptedSymmetricKeyLength: encryptedSymmetricKey?.length,
            encryptedSubjectLength: email.encryptedSubject?.length,
            subjectIvLength: email.subjectIv?.length,
            encryptedBodyLength: email.encryptedBody?.length,
            bodyIvLength: email.bodyIv?.length
        });

        // Decrypt subject and body separately (each has its own IV)
        let decryptedSubject;
        try {
            decryptedSubject = await decryptEmail(
                email.encryptedSubject,
                email.subjectIv,
                encryptedSymmetricKey,
                userPrivateKey
            );
            console.log("‚úÖ Subject decrypted successfully:", {
                decryptedLength: decryptedSubject?.length,
                preview: decryptedSubject?.substring(0, 50)
            });
        } catch (subjectError) {
            console.error("‚ùå Failed to decrypt subject:", {
                error: subjectError.message,
                errorName: subjectError.name
            });
            decryptedSubject = "(Unable to decrypt subject)";
        }

        let decryptedBody;
        try {
            decryptedBody = await decryptEmail(
                email.encryptedBody,
                email.bodyIv,
                encryptedSymmetricKey,
                userPrivateKey
            );
            console.log("‚úÖ Body decrypted successfully:", {
                decryptedLength: decryptedBody?.length,
                preview: decryptedBody?.substring(0, 50)
            });
        } catch (bodyError) {
            console.error("‚ùå Failed to decrypt body:", {
                error: bodyError.message,
                errorName: bodyError.name
            });
            decryptedBody = "(Unable to decrypt body)";
        }

        // Add attachment IDs to decrypted content
        const decryptedWithAttachments = {
            subject: decryptedSubject,
            body: decryptedBody,
            attachments: email.attachmentIds || []
        };

        console.log("‚úÖ Email decryption complete:", {
            hasSubject: !!decryptedSubject,
            hasBody: !!decryptedBody,
            attachmentCount: decryptedWithAttachments.attachments?.length || 0
        });

        return decryptedWithAttachments;

    } catch (error) {
        console.error('‚ùå Failed to decrypt email:', {
            errorMessage: error.message,
            errorName: error.name,
            errorStack: error.stack?.substring(0, 200),
            emailId: email?.id
        });
        throw error;
    }
}

// ============================================================================
// FETCH EMAILS
// ============================================================================

/**
 * Fetch inbox emails
 * @returns {Promise<Array>} List of encrypted emails
 */
export async function fetchInbox() {
    try {
        const response = await emailAPI.getInbox();
        return response.data;
    } catch (error) {
        console.error('Failed to fetch inbox:', error);
        throw error;
    }
}

/**
 * Fetch sent emails
 * @returns {Promise<Array>} List of encrypted emails
 */
export async function fetchSent() {
    try {
        const response = await emailAPI.getSent();
        return response.data;
    } catch (error) {
        console.error('Failed to fetch sent emails:', error);
        throw error;
    }
}

/**
 * Mark email as read
 * @param {number} emailId - Email ID
 * @returns {Promise<Object>} Backend response
 */
export async function markEmailAsRead(emailId) {
    try {
        const response = await emailAPI.markAsRead(emailId);
        return response.data;
    } catch (error) {
        console.error('Failed to mark email as read:', error);
        throw error;
    }
}

// ============================================================================
// EXPORTS
// ============================================================================

export default {
    sendEncryptedEmail,
    decryptEmailMessage,
    fetchInbox,
    fetchSent,
    markEmailAsRead,
};
/**
 * Address Utilities for @smail.in Internal Email Addressing
 * 
 * This module handles the custom email address format used internally
 * within the CryptaMail application. All addresses follow the pattern:
 * 
 *   username@smail.in
 * 
 * Where:
 * - username: The unique local part (3-20 chars, alphanumeric + _ .)
 * - @smail.in: The fixed domain for all internal addresses
 * 
 * These are NOT real SMTP email addresses - they are internal identifiers.
 * 
 * @module addressUtils
 */

// ============================================================================
// CONSTANTS
// ============================================================================

/**
 * The fixed email domain for all CryptaMail addresses
 * @constant {string}
 */
export const APP_EMAIL_DOMAIN = "smail.in";

/**
 * Regex pattern for valid usernames
 * - 3-20 characters
 * - Alphanumeric, underscore, dot allowed
 * - Must start and end with alphanumeric
 * @constant {RegExp}
 */
const USERNAME_PATTERN = /^[a-zA-Z0-9]([a-zA-Z0-9._]{1,18}[a-zA-Z0-9])?$/;

// ============================================================================
// VALIDATION
// ============================================================================

/**
 * Validate a username according to CryptaMail rules
 * 
 * Rules:
 * - 3-20 characters long
 * - Alphanumeric characters, underscore (_), and dot (.) allowed
 * - Must start and end with alphanumeric character
 * - No consecutive dots
 * - No spaces or special characters
 * 
 * @param {string} username - Username to validate
 * @returns {boolean} True if valid, false otherwise
 * 
 * @example
 * isValidUsername("alice")          // true
 * isValidUsername("alice_123")      // true
 * isValidUsername("alice.smith")    // true
 * isValidUsername("ab")             // false (too short)
 * isValidUsername("_alice")         // false (starts with underscore)
 * isValidUsername("alice!")         // false (special char)
 */
export function isValidUsername(username) {
    if (!username || typeof username !== 'string') {
        return false;
    }

    // Check length
    if (username.length < 3 || username.length > 20) {
        return false;
    }

    // Check pattern
    if (!USERNAME_PATTERN.test(username)) {
        return false;
    }

    // Check for consecutive dots
    if (username.includes('..')) {
        return false;
    }

    return true;
}

/**
 * Validate a full email address (username@smail.in)
 * 
 * @param {string} address - Full email address to validate
 * @returns {boolean} True if valid, false otherwise
 * 
 * @example
 * isValidAddress("alice@smail.in")     // true
 * isValidAddress("alice@gmail.com")    // false (wrong domain)
 * isValidAddress("alice")              // false (no domain)
 */
export function isValidAddress(address) {
    if (!address || typeof address !== 'string') {
        return false;
    }

    try {
        const username = parseAppEmail(address);
        return isValidUsername(username);
    } catch {
        return false;
    }
}

// ============================================================================
// FORMATTING
// ============================================================================

/**
 * Format a username into a full @smail.in address
 * 
 * @param {string} username - The username (local part)
 * @returns {string} Full email address (username@smail.in)
 * @throws {Error} If username is invalid
 * 
 * @example
 * formatAppEmail("alice")     // "alice@smail.in"
 * formatAppEmail("bob_123")   // "bob_123@smail.in"
 */
export function formatAppEmail(username) {
    if (!isValidUsername(username)) {
        throw new Error(
            `Invalid username: "${username}". ` +
            `Usernames must be 3-20 characters, alphanumeric with optional underscores/dots, ` +
            `and must start/end with alphanumeric characters.`
        );
    }

    return `${username}@${APP_EMAIL_DOMAIN}`;
}

// ============================================================================
// PARSING
// ============================================================================

/**
 * Parse a full @smail.in address and extract the username
 * 
 * @param {string} address - Full email address (username@smail.in)
 * @returns {string} The username (local part)
 * @throws {Error} If address format is invalid or domain doesn't match
 * 
 * @example
 * parseAppEmail("alice@smail.in")     // "alice"
 * parseAppEmail("bob@smail.in")       // "bob"
 * parseAppEmail("user@gmail.com")     // throws Error
 * parseAppEmail("invalid")            // throws Error
 */
export function parseAppEmail(address) {
    // Validate input
    if (!address || typeof address !== 'string') {
        throw new Error('Email address must be a non-empty string');
    }

    // Trim whitespace
    address = address.trim();

    // Split into local part and domain
    const parts = address.split('@');

    if (parts.length !== 2) {
        throw new Error(
            `Invalid email format: "${address}". ` +
            `Expected format: username@${APP_EMAIL_DOMAIN}`
        );
    }

    const [localPart, domain] = parts;

    // Validate domain
    if (domain !== APP_EMAIL_DOMAIN) {
        throw new Error(
            `Invalid domain: "${domain}". ` +
            `Only @${APP_EMAIL_DOMAIN} addresses are supported.`
        );
    }

    // Validate local part (username)
    if (!isValidUsername(localPart)) {
        throw new Error(
            `Invalid username: "${localPart}". ` +
            `Usernames must be 3-20 characters, alphanumeric with optional underscores/dots.`
        );
    }

    return localPart;
}

/**
 * Safely parse an email address, returning null instead of throwing
 * 
 * @param {string} address - Email address to parse
 * @returns {string|null} Username if valid, null otherwise
 * 
 * @example
 * tryParseAppEmail("alice@smail.in")     // "alice"
 * tryParseAppEmail("invalid@gmail.com")  // null
 */
export function tryParseAppEmail(address) {
    try {
        return parseAppEmail(address);
    } catch {
        return null;
    }
}

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Get descriptive error message for invalid username
 * 
 * @param {string} username - Username to check
 * @returns {string|null} Error message if invalid, null if valid
 */
export function getUsernameError(username) {
    if (!username) {
        return 'Username is required';
    }

    if (username.length < 3) {
        return 'Username must be at least 3 characters';
    }

    if (username.length > 20) {
        return 'Username must be at most 20 characters';
    }

    if (!USERNAME_PATTERN.test(username)) {
        return 'Username can only contain letters, numbers, dots, and underscores';
    }

    if (username.includes('..')) {
        return 'Username cannot contain consecutive dots';
    }

    if (!/^[a-zA-Z0-9]/.test(username)) {
        return 'Username must start with a letter or number';
    }

    if (!/[a-zA-Z0-9]$/.test(username)) {
        return 'Username must end with a letter or number';
    }

    return null;
}

/**
 * Normalize a username (lowercase, trim)
 * 
 * @param {string} username - Username to normalize
 * @returns {string} Normalized username
 * 
 * @example
 * normalizeUsername("  Alice  ")   // "alice"
 * normalizeUsername("BOB_123")     // "bob_123"
 */
export function normalizeUsername(username) {
    if (!username || typeof username !== 'string') {
        return '';
    }

    return username.trim().toLowerCase();
}

// ============================================================================
// EXPORTS
// ============================================================================

export default {
    APP_EMAIL_DOMAIN,
    isValidUsername,
    isValidAddress,
    formatAppEmail,
    parseAppEmail,
    tryParseAppEmail,
    getUsernameError,
    normalizeUsername,
};



----- FILE: D:\CODES\ciphermailApp\frontend\src\App.jsx -----
// Clean React app with just essential components
import React, { useEffect } from "react";
import { Routes, Route, Navigate, useLocation, useNavigate } from "react-router-dom";
import { useAuth } from "./context/AuthContext";
import { useIdleTimer } from "./hooks/useIdleTimer";
import SecurityLogger from "./utils/securityLogger";
import AuthPage from "./pages/AuthPage";
import UnlockMailbox from "./components/Auth/UnlockMailbox";
import MailApp from "./MailApp";
import CryptaMailSplash from "./components/ui/CryptaMailSplash";
import { GoogleAuthProvider } from "./context/GoogleProvider";
import ErrorBoundary from "./components/common/ErrorBoundary";
import { PageTransition } from "./utils/animation.jsx";

export default function App() {
  const { isAuthenticated, isLocked, initialized, clearSession, user } = useAuth();
  const location = useLocation();
  const navigate = useNavigate();

  // ‚ö†Ô∏è SECURITY: Set up idle timer for auto-logout (15 minutes)
  useIdleTimer(() => {
    if (isAuthenticated) {
      if (import.meta.env.DEV) {
        console.warn('‚è±Ô∏è Session timeout triggered due to inactivity');
      }
      SecurityLogger.logLogout(user?.id || 'unknown', 'session_timeout');
      clearSession();
      navigate('/login', { replace: true });
    }
  }, 15 * 60 * 1000); // 15 minutes

  // Listen for unauthorized events to globally handle session expiry
  useEffect(() => {
    const handleUnauthorized = () => {
      if (isAuthenticated) {
        if (import.meta.env.DEV) {
          console.log('Session expired or invalid. Clearing session and redirecting to login.');
        }
        clearSession();
        // Use setTimeout to avoid race conditions
        setTimeout(() => {
          navigate('/login', { replace: true });
        }, 100);
      }
    };

    window.addEventListener('unauthorized', handleUnauthorized);

    return () => {
      window.removeEventListener('unauthorized', handleUnauthorized);
    };
  }, [isAuthenticated, clearSession, navigate]);

  // Show loading spinner while auth initializes
  if (!initialized) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gradient-to-br from-gray-50 to-gray-100 dark:from-gray-900 dark:to-gray-800">
        <div className="text-center">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-4"></div>
          <p className="text-gray-600 dark:text-gray-400">Initializing secure mailbox...</p>
        </div>
      </div>
    );
  }

  // Only log in development
  if (import.meta.env.DEV) {
    console.debug('üîê App state:', { isAuthenticated, isLocked, initialized });
    console.debug('üåê Environment:', {
      client: !!import.meta.env.VITE_GOOGLE_CLIENT_ID,
      api: import.meta.env.VITE_API_BASE_URL
    });
  }

  return (
    <ErrorBoundary>
      <a href="#main-content" className="skip-to-main">
        Skip to main content
      </a>
      <GoogleAuthProvider>
        <Routes>
          <Route
            path="/login"
            element={
              !isAuthenticated && initialized ? (
                <PageTransition location="login">
                  <AuthPage />
                </PageTransition>
              ) : (
                <Navigate to="/" replace />
              )
            }
          />

          <Route
            path="/register"
            element={
              !isAuthenticated && initialized ? (
                <PageTransition location="register">
                  <AuthPage />
                </PageTransition>
              ) : (
                <Navigate to="/" replace />
              )
            }
          />

          <Route
            path="/unlock"
            element={
              isAuthenticated && isLocked ? (
                <PageTransition location="unlock">
                  <UnlockMailbox />
                </PageTransition>
              ) : (
                <Navigate to="/" replace />
              )
            }
          />

          <Route
            path="/splash"
            element={
              <PageTransition location="splash">
                <CryptaMailSplash onComplete={() => navigate('/login')} />
              </PageTransition>
            }
          />

          <Route
            path="/*"
            element={
              !isAuthenticated ? (
                <Navigate to="/login" replace />
              ) : isLocked ? (
                <Navigate to="/unlock" replace />
              ) : (
                <PageTransition location="main">
                  <MailApp />
                </PageTransition>
              )
            }
          />
        </Routes>
      </GoogleAuthProvider>
    </ErrorBoundary>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\index.css -----
/* Import auth component styles */
@import './components/Auth/authAnimated.css';

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Respect prefers-reduced-motion */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}

/* Smooth theme transitions with accessibility in mind */
* {
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

/* Skip to main content for accessibility */
.skip-to-main {
  position: absolute;
  top: -40px;
  left: 6px;
  background: #000;
  color: white;
  padding: 8px;
  text-decoration: none;
  z-index: 100;
  border-radius: 4px;
}

.skip-to-main:focus {
  top: 6px;
}

/* Focus visible improvements for better keyboard navigation */
.focus-visible:focus {
  outline: 2px solid #3b82f6;
  outline-offset: 2px;
  border-radius: 4px;
}

/* Animation performance optimizations */
.gpu-accelerated {
  transform: translateZ(0);
  backface-visibility: hidden;
  perspective: 1000px;
}

/* Dark mode specific animation fixes */
.dark .motion-safe {
  will-change: transform, opacity;
}

/* Base styles */
body {
    @apply bg-slate-50 text-slate-900 dark:bg-slate-950 dark:text-slate-100;
}

/* Legacy layout dark-mode compatibility & Scrollbars */
.dark ::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

.dark ::-webkit-scrollbar-track {
    background: #0f172a;
}

.dark ::-webkit-scrollbar-thumb {
    background: #334155;
    border-radius: 4px;
}

.dark ::-webkit-scrollbar-thumb:hover {
    background: #475569;
}

/* Input fix (VERY IMPORTANT) */
input,
textarea,
select {
    @apply bg-white text-gray-900 border-gray-300 focus:ring-blue-500 focus:border-blue-500 dark:bg-slate-800 dark:border-slate-700 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500;
}

/* Card & Container backgrounds for consistency */
.card {
    @apply bg-white dark:bg-slate-900 shadow rounded-lg;
}

/* Override plugin styles if necessary */
.dark .app,
.dark .main-container,
.dark .email-container {
    background-color: transparent;
    /* Let body handle it or use specific */
}
import { useState } from 'react';
import { motion } from 'framer-motion';
import { useAuth } from '../../context/AuthContext';
import { normalizeUsername } from '../../utils/addressUtils';
import AuthLogo from '../common/Logo';
import GoogleLogin from './GoogleLogin';
import { authVariants } from '../../utils/animation';

export default function LoginForm({ onToggle }) {
  const { login, loading, error: authError } = useAuth();
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [decrypting, setDecrypting] = useState(false);

  const handleUsernameChange = (e) => {
    const value = normalizeUsername(e.target.value);
    setUsername(value);
    setError('');
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setError('');

    if (!username || !password) {
      setError('Please enter both username and password');
      return;
    }

    try {
      setDecrypting(true);
      await login(username, password);
      // On success, AuthContext will handle navigation
    } catch (err) {
      setError(err.message || 'Login failed. Please check your credentials.');
      setDecrypting(false);
    }
  };

  return (
    <motion.div 
      className="w-full max-w-md mx-auto"
      variants={authVariants.container}
      initial="hidden"
      animate="visible"
    >
      <motion.div variants={authVariants.logo}>
        <AuthLogo />
      </motion.div>

      <motion.form 
        onSubmit={handleSubmit} 
        className="space-y-6"
        variants={authVariants.form}
      >
        {(error || authError) && (
          <motion.div 
            className="p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg text-red-600 dark:text-red-400 text-sm"
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
          >
            {error || authError}
          </motion.div>
        )}

        <div className="space-y-4">
          <motion.div variants={authVariants.field}>
            <label htmlFor="username" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Username
            </label>
            <input
              id="username"
              type="text"
              value={username}
              onChange={handleUsernameChange}
              placeholder="Enter your username"
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              disabled={loading || decrypting}
              autoComplete="username"
            />
            <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
              @smail.in
            </p>
          </motion.div>

          <motion.div variants={authVariants.field}>
            <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
              Password
            </label>
            <input
              id="password"
              type="password"
              value={password}
              onChange={(e) => {
                setPassword(e.target.value);
                setError('');
              }}
              placeholder="Enter your password"
              className="w-full px-4 py-3 border border-gray-300 dark:border-gray-600 rounded-lg 
                       focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                       bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                       transition-all duration-200"
              disabled={loading || decrypting}
              autoComplete="current-password"
            />
          </motion.div>
        </div>

        <motion.div variants={authVariants.field} className="space-y-4">
          <motion.button
            type="submit"
            disabled={loading || decrypting || !username || !password}
            className="w-full py-3 px-4 bg-gradient-to-r from-indigo-600 to-indigo-700 hover:from-indigo-700 hover:to-indigo-800 disabled:from-gray-400 disabled:to-gray-500 
                     text-white font-semibold rounded-lg shadow-lg hover:shadow-xl disabled:shadow-none 
                     transition-all duration-300 disabled:cursor-not-allowed
                     flex items-center justify-center gap-2 relative overflow-hidden group"
            whileHover={{ scale: loading || decrypting ? 1 : 1.02 }}
            whileTap={{ scale: loading || decrypting ? 1 : 0.98 }}
          >
            {(loading || decrypting) ? (
              <>
                <div className="w-4 h-4 border-2 border-white border-t-transparent rounded-full animate-spin"></div>
                {decrypting ? 'Decrypting...' : 'Signing In...'}
              </>
            ) : (
              'Sign In'
            )}
          </motion.button>

          <div className="relative">
            <div className="absolute inset-0 flex items-center">
              <div className="w-full border-t border-gray-300 dark:border-gray-600"></div>
            </div>
            <div className="relative flex justify-center text-sm">
              <span className="px-2 bg-white dark:bg-gray-800 text-gray-500 dark:text-gray-400">
                Or continue with
              </span>
            </div>
          </div>

          <GoogleLogin />
        </motion.div>
      </motion.form>
    </motion.div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Auth\PasswordStrength.jsx -----
import zxcvbn from "zxcvbn";

export default function PasswordStrength({ password }) {
  if (!password) return null;

  const { score, feedback } = zxcvbn(password);

  const colors = [
    "bg-red-500",
    "bg-orange-500",
    "bg-yellow-400",
    "bg-blue-500",
    "bg-green-500"
  ];

  const labels = [
    "Very weak",
    "Weak",
    "Fair",
    "Good",
    "Strong"
  ];

  return (
    <div className="mt-2">
      <div className="h-2 w-full bg-gray-200 rounded">
        <div
          className={`h-2 rounded ${colors[score]}`}
          style={{ width: `${(score + 1) * 20}%` }}
        />
      </div>
      <p className="text-sm mt-1 text-gray-600">
        {labels[score]}
        {feedback.warning && ` ‚Äì ${feedback.warning}`}
      </p>
    </div>
  );
}
----- FILE: D:\CODES\ciphermailApp\frontend\src\components\common\Logo.jsx -----
import { motion } from 'framer-motion';
import CryptaMailIcon from '../ui/CryptaMailIcon';

export default function AuthLogo({ className = "" }) {
  return (
    <motion.div 
      className={`flex flex-col items-center justify-center mb-8 ${className}`}
      initial={{ opacity: 0, scale: 0.8 }}
      animate={{ opacity: 1, scale: 1 }}
      transition={{ duration: 0.6, ease: "easeOut" }}
    >
      <motion.div
        initial={{ opacity: 0, y: -20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5, delay: 0.2 }}
        className="mb-3"
      >
        <CryptaMailIcon size={48} animated={false} />
      </motion.div>
      
      <motion.h1 
        className="text-2xl font-bold text-gray-900 dark:text-white"
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5, delay: 0.3 }}
      >
        CryptaMail
      </motion.h1>
      
      <motion.p 
        className="text-sm text-gray-600 dark:text-gray-400 mt-1"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        transition={{ duration: 0.5, delay: 0.4 }}
      >
        End-to-End Encrypted Email
      </motion.p>
    </motion.div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Email\AttachmentItem.jsx -----
import { useState, useEffect } from "react";
import { emailAPI } from "../../services/apiService";
import {
    decryptFile,
    decryptFilename,
    decryptAESKeyWithRSA,
    decryptChunk,
    base64ToArrayBuffer
} from "../../utils/cryptoUtils";

export default function AttachmentItem({ attachment: initialAttachment, userPrivateKey, isSender }) {
    const [attachment, setAttachment] = useState(initialAttachment);
    const [filename, setFilename] = useState("Decrypting name...");
    const [downloading, setDownloading] = useState(false);
    const [progress, setProgress] = useState(0);
    const [metadataLoading, setMetadataLoading] = useState(typeof initialAttachment === 'number' || !initialAttachment.encryptedFilename);

    useEffect(() => {
        const loadMetadata = async () => {
            if (typeof attachment === 'number' || !attachment.encryptedFilename) {
                try {
                    const id = typeof attachment === 'number' ? attachment : attachment.id;
                    const res = await emailAPI.getAttachmentMetadata(id);
                    setAttachment(res.data);
                    setMetadataLoading(false);
                } catch (e) {
                    console.error("Failed to load attachment metadata:", {
                        error: e.message,
                        status: e.response?.status,
                        data: e.response?.data
                    });
                    setFilename("Unavailable File");
                    setMetadataLoading(false);
                }
            }
        };
        loadMetadata();
    }, [attachment]);

    useEffect(() => {
        // Decrypt filename immediately for display
        const decryptName = async () => {
            if (metadataLoading || !attachment || !attachment.encryptedFilename) return;

            // If filenameIv is missing, use plain filename
            if (!attachment.filenameIv || attachment.filenameIv.trim() === '') {
                setFilename(attachment.encryptedFilename);
                return;
            }

            // Try multiple ways to get the encrypted key
            let encryptedKey = isSender ? attachment.encryptedKeySender : attachment.encryptedKeyRecipient;

            // Fallback: try the other key if the first one is missing
            if (!encryptedKey) {
                encryptedKey = isSender ? attachment.encryptedKeyRecipient : attachment.encryptedKeySender;
            }

            // Fallback: try any available key
            if (!encryptedKey) {
                encryptedKey = attachment.encryptedKeySender || attachment.encryptedKeyRecipient;
            }

            // Validate encryptedKey before attempting decryption
            if (!encryptedKey || typeof encryptedKey !== 'string' || encryptedKey.trim() === '') {
                console.error("Invalid encrypted key for filename decryption", {
                    isSender,
                    encryptedKeySender: attachment.encryptedKeySender ? "present" : "missing",
                    encryptedKeyRecipient: attachment.encryptedKeyRecipient ? "present" : "missing"
                });
                setFilename(attachment.encryptedFilename); // Fallback to stored filename
                return;
            }

            try {
                const name = await decryptFilename(
                    attachment.encryptedFilename,
                    attachment.filenameIv,
                    encryptedKey,
                    userPrivateKey
                );
                setFilename(name);
            } catch (e) {
                console.error("Name decryption failed", e);
                setFilename(attachment.encryptedFilename); // Fallback to stored filename
            }
        };
        decryptName();
    }, [attachment, userPrivateKey, isSender, metadataLoading]);

    const handleDownload = async () => {
        setDownloading(true);
        setProgress(0);

        try {
            // Debug: Log attachment structure
            console.log("Attachment data for download:", {
                id: attachment.id,
                encryptedKeySender: !!attachment.encryptedKeySender,
                encryptedKeyRecipient: !!attachment.encryptedKeyRecipient,
                isSender,
                totalChunks: attachment.totalChunks,
                encryptedBlob: !!attachment.encryptedBlob
            });

            // Try multiple ways to get the encrypted key
            let encryptedKey = isSender ? attachment.encryptedKeySender : attachment.encryptedKeyRecipient;

            // Fallback: try the other key if the first one is missing
            if (!encryptedKey) {
                encryptedKey = isSender ? attachment.encryptedKeyRecipient : attachment.encryptedKeySender;
            }

            // Fallback: try any available key
            if (!encryptedKey) {
                encryptedKey = attachment.encryptedKeySender || attachment.encryptedKeyRecipient;
            }

            // Validate encryptedKey before attempting decryption
            if (!encryptedKey || typeof encryptedKey !== 'string' || encryptedKey.trim() === '') {
                console.error("Invalid encrypted key for download", {
                    isSender,
                    encryptedKeySender: attachment.encryptedKeySender ? "present" : "missing",
                    encryptedKeyRecipient: attachment.encryptedKeyRecipient ? "present" : "missing",
                    allAttachmentKeys: Object.keys(attachment).filter(key => key.includes('encryptedKey'))
                });
                throw new Error("Invalid encrypted key: missing or empty");
            }

            console.log("üîì About to decrypt AES key", {
                encryptedKeyLength: encryptedKey.length,
                hasUserPrivateKey: !!userPrivateKey,
                userPrivateKeyType: userPrivateKey?.constructor?.name,
                userPrivateKeyTypeOf: typeof userPrivateKey,
                userPrivateKeyAlgorithm: userPrivateKey?.algorithm?.name,
                userPrivateKeyType2: userPrivateKey?.type,
                isSender,
                selectedKey: isSender ? 'encryptedKeySender' : 'encryptedKeyRecipient'
            });

            let aesKey;
            try {
                aesKey = await decryptAESKeyWithRSA(encryptedKey, userPrivateKey);
            } catch (keyDecryptError) {
                console.warn("‚ö†Ô∏è Primary key decryption failed, trying alternate key...", {
                    primaryError: keyDecryptError.message,
                    encryptedKeyLength: encryptedKey?.length,
                    userPrivateKeyAlgorithm: userPrivateKey?.algorithm?.name
                });

                // Try the alternate key
                const alternateKey = isSender ? attachment.encryptedKeyRecipient : attachment.encryptedKeySender;
                if (alternateKey && alternateKey !== encryptedKey) {
                    try {
                        console.log("üîÑ Trying alternate encrypted key...");
                        aesKey = await decryptAESKeyWithRSA(alternateKey, userPrivateKey);
                        console.log("‚úÖ Alternate key decrypted successfully");
                    } catch (alternateError) {
                        console.error("‚ùå Both key decryptions FAILED:", {
                            primaryError: keyDecryptError.message,
                            alternateError: alternateError.message,
                            userPrivateKeyValid: !!userPrivateKey,
                            keyType: userPrivateKey?.type,
                            algorithm: userPrivateKey?.algorithm?.name,
                            usages: userPrivateKey?.usages,
                            extractable: userPrivateKey?.extractable,
                            isSender,
                            primaryKeyUsed: isSender ? 'encryptedKeySender' : 'encryptedKeyRecipient',
                            alternateKeyUsed: isSender ? 'encryptedKeyRecipient' : 'encryptedKeySender'
                        });
                        throw new Error(`Cannot decrypt AES key: ${keyDecryptError.message}`);
                    }
                } else {
                    console.error("‚ùå AES key decryption FAILED (no alternate):", {
                        error: keyDecryptError.message,
                        errorStack: keyDecryptError.stack,
                        userPrivateKeyValid: !!userPrivateKey,
                        keyType: userPrivateKey?.type,
                        algorithm: userPrivateKey?.algorithm?.name,
                        usages: userPrivateKey?.usages,
                        extractable: userPrivateKey?.extractable,
                        availableKeys: {
                            hasSender: !!attachment.encryptedKeySender,
                            hasRecipient: !!attachment.encryptedKeyRecipient
                        }
                    });
                    throw new Error(`Cannot decrypt AES key: ${keyDecryptError.message}`);
                }
            }

            console.log("üîì AES key decrypted successfully", {
                aesKeyType: aesKey?.constructor?.name,
                aesKeyAlgorithm: aesKey?.algorithm?.name,
                aesKeyUsages: aesKey?.usages,
                aesKeyLength: aesKey?.algorithm?.length
            });

            const chunks = [];

            // Phase 2: Chunked
            if (attachment.totalChunks !== undefined && attachment.totalChunks !== null) {
                if (attachment.totalChunks === 0) {
                    // Empty file
                } else if (attachment.totalChunks > 0) {
                    for (let i = 0; i < attachment.totalChunks; i++) {
                        try {
                            const res = await emailAPI.getAttachmentChunk(attachment.id, i);
                            const encDataB64 = res.data.encryptedData;
                            const ivStr = res.data.iv;

                            if (!encDataB64 || typeof encDataB64 !== 'string' || encDataB64.trim() === '') {
                                throw new Error(`Invalid encrypted data for chunk ${i}`);
                            }
                            if (!ivStr || typeof ivStr !== 'string' || ivStr.trim() === '') {
                                throw new Error(`Invalid IV for chunk ${i}`);
                            }


                            console.log(`üì¶ Chunk ${i} received from server`, {
                                encDataLength: encDataB64.length, // Should be approx 6.6MB for 5MB chunk
                                ivLength: ivStr.length,
                                encDataStart: encDataB64.substring(0, 50),
                                ivStart: ivStr.substring(0, 50)
                            });

                            // Backend returns encryptedData and iv as base64 strings
                            const encryptedChunkBuffer = base64ToArrayBuffer(encDataB64);
                            const ivBuffer = base64ToArrayBuffer(ivStr);
                            const ivUint8 = new Uint8Array(ivBuffer);

                            console.log(`üîì About to decrypt chunk ${i}`, {
                                encryptedBufferLength: encryptedChunkBuffer.byteLength,
                                ivLength: ivUint8.length,
                                ivStart: Array.from(ivUint8.slice(0, 4)).map(b => b.toString(16)).join(' '),
                                aesKeyType: aesKey?.constructor?.name,
                                aesKeyAlgorithm: aesKey?.algorithm?.name
                            });

                            const decryptedAB = await decryptChunk(encryptedChunkBuffer, aesKey, ivUint8);
                            chunks.push(new Uint8Array(decryptedAB));

                            console.log(`‚úÖ Chunk ${i} decrypted successfully`, {
                                decryptedLength: decryptedAB.byteLength
                            });

                            setProgress(Math.round(((i + 1) / attachment.totalChunks) * 100));
                        } catch (chunkErr) {
                            console.error(`Error processing chunk ${i}:`, chunkErr);
                            throw chunkErr;
                        }
                    }
                }
            } else {
                // Phase 1: Legacy fallback
                if (!attachment.encryptedBlob) {
                    throw new Error("Legacy attachment missing 'encryptedBlob'.");
                }
                const decryptedAB = await decryptFile(
                    attachment.encryptedBlob,
                    attachment.iv,
                    encryptedKey,
                    userPrivateKey
                );
                chunks.push(new Uint8Array(decryptedAB));
                setProgress(100);
            }

            const blob = new Blob(chunks, { type: attachment.mimeType || "application/octet-stream" });

            // Removed empty check to allow 0-byte files

            const url = window.URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename; // Essential

            document.body.appendChild(a);
            a.click();

            document.body.removeChild(a);
            setTimeout(() => window.URL.revokeObjectURL(url), 100);

        } catch (error) {
            console.error("Download failed", error);
            alert("Failed to download: " + error.message);
        } finally {
            setDownloading(false);
            setProgress(0);
        }
    };

    return (
        <div className="flex items-center justify-between p-3 border rounded-lg bg-slate-50 dark:bg-slate-800 dark:border-slate-700">
            <div className="flex items-center gap-3 overflow-hidden">
                <span className="text-2xl">
                    {attachment?.mimeType?.includes("image") ? "üñºÔ∏è" : "üìÑ"}
                </span>
                <div className="flex flex-col min-w-0">
                    <span className="text-sm font-medium truncate dark:text-slate-200" title={filename}>
                        {filename}
                    </span>
                    <span className="text-xs text-slate-500">
                        {attachment?.size ? (attachment.size / 1024).toFixed(1) + " KB" : "..."}
                    </span>
                </div>
            </div>
            <button
                onClick={handleDownload}
                disabled={downloading || metadataLoading || typeof attachment !== 'object'}
                className="ml-2 px-3 py-1 text-xs font-medium text-indigo-600 bg-indigo-50 hover:bg-indigo-100 rounded-full dark:bg-slate-700 dark:text-indigo-400 dark:hover:bg-slate-600 transition-colors"
            >
                {downloading ? "..." : "‚¨á"}
            </button>
        </div>
    );
}
import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { emailAPI, userAPI } from "../../services/apiService";
import { sendEncryptedEmail } from "../../services/emailService";
import { useAuth } from "../../context/AuthContext";
import { encryptEmail, importPublicKey, arrayBufferToBase64, generateAESKey, encryptChunk, encryptAESKeyWithRSA, CHUNK_SIZE } from "../../utils/cryptoUtils";
import CryptaMailLoader from "../ui/CryptaMailLoader";

export default function ComposeModal({ onClose, onEmailSent, initialData = null }) {
  const { user } = useAuth();
  const myPublicKey = user?.publicKey;
  const [to, setTo] = useState(initialData?.to ? (initialData.to.includes('@') ? initialData.to : initialData.to + '@smail.in') : "");
  const [subject, setSubject] = useState(initialData?.subject || "");
  const [body, setBody] = useState(initialData?.body || "");
  const [loading, setLoading] = useState(false);
  const [files, setFiles] = useState([]);

  const handleFileChange = (e) => {
    const selectedFiles = Array.from(e.target.files);
    setFiles(prev => [...prev, ...selectedFiles]);
  };

  const removeFile = (index) => {
    setFiles(prev => prev.filter((_, i) => i !== index));
  };

const uploadAttachment = async (file) => {
    try {
      // Step 1: Get recipient's public key
      const toEmail = to.includes('@') ? to : `${to}@smail.in`;
      const recipientResponse = await userAPI.getPublicKey(toEmail);
      const recipientPublicKey = await importPublicKey(recipientResponse.data.publicKey);

      // Step 2: Generate AES key for file encryption
      const aesKey = await generateAESKey();

      // Step 3: Read file and encrypt in chunks
      const fileContent = await file.arrayBuffer();
      const chunkSize = Math.min(CHUNK_SIZE, 5 * 1024 * 1024); // 5MB per chunk
      const totalChunks = Math.ceil(fileContent.byteLength / chunkSize);

      // Step 4: Encrypt filename
      const filenameIv = window.crypto.getRandomValues(new Uint8Array(12));
      const encryptedFilenameBuffer = await window.crypto.subtle.encrypt(
        { name: "AES-GCM", iv: filenameIv },
        aesKey,
        new TextEncoder().encode(file.name)
      );
      const encryptedFilenameB64 = arrayBufferToBase64(encryptedFilenameBuffer);
      // Convert IV to base64 - create a proper ArrayBuffer slice to avoid buffer size issues
      const filenameIvArrayBuffer = filenameIv.buffer.slice(filenameIv.byteOffset, filenameIv.byteOffset + filenameIv.byteLength);
      const filenameIvB64 = arrayBufferToBase64(filenameIvArrayBuffer);

      // Step 5: Encrypt AES key for both sender and recipient
      const senderPublicKeyObj = await importPublicKey(user.publicKey);
      const encryptedKeyRecipient = await encryptAESKeyWithRSA(aesKey, recipientPublicKey);
      const encryptedKeySender = await encryptAESKeyWithRSA(aesKey, senderPublicKeyObj);

      // Step 6: Initialize upload
      const initResponse = await emailAPI.initAttachment({
        encryptedFilename: encryptedFilenameB64,
        filenameIv: filenameIvB64,
        encryptedKeySender: encryptedKeySender,
        encryptedKeyRecipient: encryptedKeyRecipient,
        mimeType: file.type,
        totalSize: fileContent.byteLength,
        totalChunks: totalChunks
      });

      const attachmentId = initResponse.data.id;

      // Step 7: Upload encrypted chunks
      for (let i = 0; i < totalChunks; i++) {
        const start = i * chunkSize;
        const end = Math.min(start + chunkSize, fileContent.byteLength);
        const chunkBuffer = new Uint8Array(fileContent.slice(start, end));

        // Encrypt this chunk
        const encryptedChunk = await encryptChunk(chunkBuffer, aesKey);
        // encryptChunk returns { encryptedData: ArrayBuffer, iv: Uint8Array }
        const encryptedDataB64 = arrayBufferToBase64(encryptedChunk.encryptedData);
        // Convert Uint8Array IV to base64 - create a proper ArrayBuffer slice to avoid buffer size issues
        const ivArrayBuffer = encryptedChunk.iv.buffer.slice(encryptedChunk.iv.byteOffset, encryptedChunk.iv.byteOffset + encryptedChunk.iv.byteLength);
        const ivB64 = arrayBufferToBase64(ivArrayBuffer);

        try {
          await emailAPI.uploadChunk(attachmentId, {
            chunkIndex: i,
            encryptedData: encryptedDataB64,
            iv: ivB64,
            size: chunkBuffer.length
          });
        } catch (chunkError) {
          throw new Error(`Chunk ${i} upload failed: ${chunkError.message}`);
        }
      }

      // Step 8: Complete upload
      await emailAPI.completeAttachment(attachmentId);
      return attachmentId;
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error('Failed to upload attachment:', error);
      }
      throw new Error(`Failed to upload ${file.name}: ${error.message}`);
    }
  };

  const send = async (saveAsDraft = false) => {
    if (!to || (!subject && !body)) {
      alert("Please fill in recipient and at least subject or body");
      return;
    }

    setLoading(true);
    try {
      if (!user?.publicKey) {
        throw new Error("Your public key is missing. Please re-login.");
      }

      // Upload attachments first
      const attachmentIds = [];
      for (const file of files) {
        const attachmentId = await uploadAttachment(file);
        attachmentIds.push(attachmentId);
      }

      // Encrypt the email content
      const recipientResponse = await userAPI.getPublicKey(to);
      const recipientPublicKey = await importPublicKey(recipientResponse.data.publicKey);
      const senderPublicKey = await importPublicKey(user.publicKey);

      const encryptedEmail = await encryptEmail(subject || "(No Subject)", body || "", recipientPublicKey, senderPublicKey);

      await sendEncryptedEmail({
        toAddress: to,
        subject: encryptedEmail.encryptedSubject,
        body: encryptedEmail.encryptedBody,
        senderPublicKeyB64: user.publicKey,
        attachmentIds: attachmentIds,
        subjectIv: encryptedEmail.subjectIv,
        bodyIv: encryptedEmail.bodyIv,
        encryptedSymmetricKey: encryptedEmail.encryptedSymmetricKey,
        senderEncryptedSymmetricKey: encryptedEmail.senderEncryptedSymmetricKey
      });

      onEmailSent();
      onClose(); // Auto close on success
    } catch (error) {
      console.error("Failed to send email:", error);
      alert(`Failed to send email: ${error.message || "Unknown error"}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <AnimatePresence>
      <motion.div
        className="fixed inset-0 bg-black/40 flex justify-center items-center z-50"
        initial={{ opacity: 0 }}
        animate={{ opacity: 1 }}
        exit={{ opacity: 0 }}
        transition={{ duration: 0.2 }}
        onClick={onClose}
      >
        <motion.div
          className="bg-white dark:bg-gray-900 p-6 rounded-xl w-full max-w-lg shadow-2xl relative"
          initial={{ scale: 0.9, opacity: 0, y: 20 }}
          animate={{ scale: 1, opacity: 1, y: 0 }}
          exit={{ scale: 0.9, opacity: 0, y: 20 }}
          transition={{ type: "spring", damping: 20, stiffness: 300 }}
          onClick={(e) => e.stopPropagation()}
        >
          <div className="flex justify-between items-center mb-4">
            <motion.h2
              className="text-xl font-bold dark:text-white"
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              transition={{ duration: 0.3 }}
            >
              Compose Email
            </motion.h2>

            <motion.button
              onClick={onClose}
              className="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors"
              whileHover={{ scale: 1.1 }}
              whileTap={{ scale: 0.9 }}
            >
              ‚úï
            </motion.button>
          </div>

          <motion.div
            className="space-y-4"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.4, delay: 0.1 }}
          >
            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                To
              </label>
              <input
                type="email"
                value={to}
                onChange={(e) => setTo(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg 
                         focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                placeholder="recipient@example.com"
                disabled={loading}
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Subject
              </label>
              <input
                type="text"
                value={subject}
                onChange={(e) => setSubject(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg 
                         focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-white"
                placeholder="Email subject"
                disabled={loading}
              />
            </div>

            <div>
              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                Message
              </label>
              <textarea
                value={body}
                onChange={(e) => setBody(e.target.value)}
                className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg 
                         focus:ring-2 focus:ring-indigo-500 focus:border-transparent 
                         bg-white dark:bg-gray-700 text-gray-900 dark:text-white
                         h-32 resize-none"
                placeholder="Your message..."
                disabled={loading}
              />
            </div>

            {files.length > 0 && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: "auto" }}
                exit={{ opacity: 0, height: 0 }}
                transition={{ duration: 0.3 }}
              >
                <div className="text-sm text-gray-600 dark:text-gray-400 mb-2">
                  Attachments:
                </div>
                <div className="space-y-2">
                  {files.map((file, index) => (
                    <motion.div
                      key={index}
                      initial={{ opacity: 0, x: -20 }}
                      animate={{ opacity: 1, x: 0 }}
                      exit={{ opacity: 0, x: 20 }}
                      transition={{ duration: 0.2 }}
                      className="flex items-center justify-between p-2 bg-gray-50 dark:bg-gray-800 rounded"
                    >
                      <span className="text-sm truncate">{file.name}</span>
                      <button
                        onClick={() => removeFile(index)}
                        className="text-red-500 hover:text-red-700 text-sm"
                      >
                        Remove
                      </button>
                    </motion.div>
                  ))}
                </div>
              </motion.div>
            )}

            <div className="flex gap-2">
              <input
                type="file"
                multiple
                onChange={handleFileChange}
                className="hidden"
                id="file-input"
              />
              <label
                htmlFor="file-input"
                className="px-4 py-2 text-gray-600 dark:text-gray-300 bg-gray-100 dark:bg-gray-800 rounded-lg cursor-pointer hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
              >
                üìé Attach
              </label>
            </div>
          </motion.div>

          <motion.div
            className="flex gap-2 mt-6 justify-end"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5, delay: 0.2 }}
          >
            <motion.button
              onClick={onClose}
              className="px-4 py-2 text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition-colors"
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              disabled={loading}
            >
              Cancel
            </motion.button>
            <motion.button
              onClick={() => send(false)}
              className="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded transition-colors flex items-center gap-2"
              disabled={loading}
              whileHover={{ scale: loading ? 1 : 1.05, boxShadow: "0 4px 20px rgba(99, 102, 241, 0.3)" }}
              whileTap={{ scale: loading ? 1 : 0.95 }}
            >
              {loading ? (
                <>
                  <CryptaMailLoader size={16} />
                  <span>Sending...</span>
                </>
              ) : "Send"}
            </motion.button>
          </motion.div>
        </motion.div>
      </motion.div>
    </AnimatePresence>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\Email\EmailList.jsx -----
import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useAuth } from "../../context/AuthContext";
import { decryptEmailMessage } from "../../services/emailService";
import { emailAPI } from "../../services/apiService";
import { groupEmailsIntoThreads, getThreadSummary, shouldEnableThreading } from "../../utils/emailThreading";

export default function EmailList({
  emails,
  onEmailClick,
  onRefresh,
  selectedEmailId,
  viewType,
  onEmptyTrash,
}) {
  const { privateKey, isLocked } = useAuth();
  const [decryptedSubjects, setDecryptedSubjects] = useState({});
  const [emptyingTrash, setEmptyingTrash] = useState(false);
  const [restoringEmails, setRestoringEmails] = useState(new Set());
  const [searchTerm, setSearchTerm] = useState('');
  const [filterType, setFilterType] = useState('all');
  const [viewMode, setViewMode] = useState('list');

  useEffect(() => {
    let cancelled = false;
    
    const decryptSubjects = async () => {
      if (!privateKey || !emails.length) {
        if (!cancelled) {
          setDecryptedSubjects({});
        }
        return;
      }

      console.log("üîì Starting to decrypt email subjects:", {
        emailCount: emails.length,
        hasPrivateKey: !!privateKey,
        privateKeyType: privateKey?.type,
        privateKeyAlgorithm: privateKey?.algorithm?.name
      });

      const newDecrypted = {};
      let successCount = 0;
      let failureCount = 0;

      for (const email of emails) {
        if (cancelled) break;
        
        try {
          console.log(`üîÑ Decrypting subject for email ${email.id}...`, {
            fromUsername: email.fromUsername,
            hasEncryptedSubject: !!email.encryptedSubject,
            hasSubjectIv: !!email.subjectIv
          });

          const decrypted = await decryptEmailMessage(email, privateKey, viewType);
          if (!cancelled) {
            newDecrypted[email.id] = decrypted.subject;
            successCount++;
            console.log(`‚úÖ Email ${email.id} subject decrypted:`, decrypted.subject?.substring(0, 50));
          }
        } catch (error) {
          failureCount++;
          console.error(`‚ùå Failed to decrypt subject for email ${email.id}:`, {
            errorMessage: error.message,
            errorName: error.name,
            fromUsername: email.fromUsername
          });
          if (!cancelled) {
            newDecrypted[email.id] = "(Unable to decrypt)";
          }
        }
      }

      if (!cancelled) {
        console.log("‚úÖ Subject decryption complete:", {
          totalEmails: emails.length,
          successCount,
          failureCount
        });
        setDecryptedSubjects(newDecrypted);
      }
    };

    decryptSubjects();

    return () => {
      cancelled = true;
    };
  }, [emails, privateKey, viewType]);

  const handleEmptyTrash = async () => {
    try {
      setEmptyingTrash(true);
      const response = await emailAPI.emptyTrash();
      const deletedCount = response.data?.deletedCount || 0;
      alert(`Successfully deleted ${deletedCount} email${deletedCount !== 1 ? 's' : ''} from trash.`);
      if (onEmptyTrash) onEmptyTrash();
    } catch (error) {
      console.error("Failed to empty trash:", error);
      alert("Failed to empty trash");
    } finally {
      setEmptyingTrash(false);
    }
  };

  const handleStarToggle = async (emailId, event) => {
    event.stopPropagation();
    try {
      const email = emails.find(e => e.id === emailId);
      if (!email) return;

      const newStarredState = !email.isStarred;
      await emailAPI.toggleStar(emailId, newStarredState);
    } catch (error) {
      console.error("Failed to toggle star:", error);
    }
  };

  const formatDate = (timestamp) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffTime = Math.abs(now - date);
    const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

    if (diffDays === 0) {
      return date.toLocaleTimeString("en-US", {
        hour: '2-digit',
        minute: '2-digit'
      });
    } else if (diffDays === 1) {
      return 'Yesterday';
    } else if (diffDays < 7) {
      return date.toLocaleDateString("en-US", { weekday: 'short' });
    } else {
      return date.toLocaleDateString("en-US", {
        year: 'numeric',
        month: 'short',
        day: 'numeric'
      });
    }
  };

  const formatAddress = (username) => {
    if (!username) return "Unknown";
    return `${username}@smail.in`;
  };

  const filteredEmails = emails.filter(email => {
    const matchesSearch = searchTerm === '' || 
      (decryptedSubjects[email.id] || '').toLowerCase().includes(searchTerm.toLowerCase()) ||
      email.fromUsername?.toLowerCase().includes(searchTerm.toLowerCase()) ||
      email.toUsername?.toLowerCase().includes(searchTerm.toLowerCase());

    if (!matchesSearch) return false;

    switch (filterType) {
      case 'unread':
        return !email.isRead;
      case 'starred':
        return email.isStarred;
      case 'important':
        return email.isImportant;
      default:
        return true;
    }
  });

  return (
    <div className="h-full flex flex-col bg-white dark:bg-slate-900">
      {/* Search and Filter Bar */}
      <div className="p-4 bg-white dark:bg-slate-800 border-b border-slate-200 dark:border-slate-700">
        <div className="flex flex-col sm:flex-row gap-3">
          <div className="flex-1">
            <div className="relative">
              <input
                type="text"
                placeholder="Search emails..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="w-full pl-10 pr-4 py-2 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent dark:bg-slate-700 dark:text-white"
              />
              <svg 
                className="absolute left-3 top-2.5 w-4 h-4 text-slate-400" 
                fill="none" 
                stroke="currentColor" 
                viewBox="0 0 24 24"
              >
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
              </svg>
            </div>
          </div>

          <div className="flex gap-2 items-center">
            <div className="flex bg-slate-100 dark:bg-slate-700 rounded-lg p-1">
              <button
                onClick={() => setFilterType('all')}
                className={`px-3 py-1.5 text-sm rounded-md transition-colors ${
                  filterType === 'all'
                    ? 'bg-white dark:bg-slate-600 text-indigo-600 dark:text-indigo-400 shadow-sm'
                    : 'text-slate-600 dark:text-slate-300 hover:text-slate-800 dark:hover:text-slate-100'
                }`}
              >
                All
              </button>
              <button
                onClick={() => setFilterType('unread')}
                className={`px-3 py-1.5 text-sm rounded-md transition-colors ${
                  filterType === 'unread'
                    ? 'bg-white dark:bg-slate-600 text-indigo-600 dark:text-indigo-400 shadow-sm'
                    : 'text-slate-600 dark:text-slate-300 hover:text-slate-800 dark:hover:text-slate-100'
                }`}
              >
                Unread
              </button>
              <button
                onClick={() => setFilterType('starred')}
                className={`px-3 py-1.5 text-sm rounded-md transition-colors ${
                  filterType === 'starred'
                    ? 'bg-white dark:bg-slate-600 text-indigo-600 dark:text-indigo-400 shadow-sm'
                    : 'text-slate-600 dark:text-slate-300 hover:text-slate-800 dark:hover:text-slate-100'
                }`}
              >
                Starred
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Email List */}
      <div className="flex-1 overflow-y-auto custom-scrollbar p-2">
        {/* Delete All Trash button - only show in trash view with emails */}
        {viewType === "trash" && filteredEmails.length > 0 && (
          <motion.div 
            className="mb-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg"
            initial={{ opacity: 0, y: -20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.3 }}
          >
            <div className="flex items-center justify-between">
              <div className="text-sm text-red-700 dark:text-red-300">
                <span className="font-medium">{filteredEmails.length}</span> items in trash
              </div>
              <button
                onClick={handleEmptyTrash}
                disabled={emptyingTrash}
                className="px-3 py-1 text-sm bg-red-600 hover:bg-red-700 disabled:bg-red-400 text-white rounded-lg transition-colors duration-200 flex items-center gap-2"
              >
                {emptyingTrash ? (
                  <>
                    <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                    </svg>
                    Deleting...
                  </>
                ) : (
                  <>
                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                    Empty Trash
                  </>
                )}
              </button>
            </div>
          </motion.div>
        )}

        {/* Empty State */}
        {filteredEmails.length === 0 ? (
          <motion.div 
            className="flex flex-col items-center justify-center h-96 text-center text-slate-500 dark:text-slate-400 p-8"
            initial={{ opacity: 0, scale: 0.9 }}
            animate={{ opacity: 1, scale: 1 }}
            transition={{ duration: 0.4 }}
          >
            <motion.div 
              className="text-6xl mb-4"
              animate={{ 
                scale: [1, 1.1, 1],
                rotate: [0, 5, -5, 0]
              }}
              transition={{ 
                duration: 2, 
                repeat: Infinity, 
                repeatDelay: 3 
              }}
            >
              {searchTerm ? 'üîç' : 'üì≠'}
            </motion.div>
            <motion.p 
              className="text-lg"
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ delay: 0.2 }}
            >
              {searchTerm 
                ? `No emails found matching "${searchTerm}"` 
                : `No ${filterType} emails in ${viewType}`
              }
            </motion.p>
            {viewType === "trash" && !searchTerm && (
              <motion.p 
                className="text-sm text-slate-400 mt-4"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 0.3 }}
              >
                Your trash folder is empty.
              </motion.p>
            )}
          </motion.div>
        ) : (
          /* Email List */
          <AnimatePresence mode="popLayout">
            <motion.div
              initial="hidden"
              animate="visible"
              className="space-y-2"
            >
              {filteredEmails.map((email, index) => {
                const isSelected = email.id === selectedEmailId;
                const otherParty =
                  viewType === "inbox"
                    ? formatAddress(email.fromUsername)
                    : formatAddress(email.toUsername);

                return (
                  <motion.div
                    key={email.id}
                    initial={{ opacity: 0, y: 20, scale: 0.95 }}
                    animate={{ opacity: 1, y: 0, scale: 1 }}
                    exit={{ opacity: 0, y: -20, scale: 0.95 }}
                    transition={{ 
                      duration: 0.3, 
                      delay: index * 0.05,
                      type: "spring",
                      damping: 20,
                      stiffness: 300
                    }}
                    className={`group p-4 mb-2 rounded-xl cursor-pointer border transition-all ${
                      isSelected
                        ? "bg-indigo-50 dark:bg-indigo-900/20 border-indigo-200 dark:border-indigo-700 shadow-md ring-1 ring-indigo-500/20"
                        : "bg-white dark:bg-slate-800 border-transparent hover:border-slate-200 dark:hover:border-slate-700 hover:shadow-md"
                    } ${!email.isRead && viewType === "inbox" ? "font-semibold border-l-4 border-l-indigo-500 bg-slate-50 dark:bg-slate-800/50" : ""}`}
                    onClick={() => onEmailClick(email)}
                    whileHover={{ 
                      scale: 1.02, 
                      boxShadow: "0 4px 20px rgba(0,0,0,0.1)",
                      transition: { duration: 0.2 }
                    }}
                    whileTap={{ scale: 0.98 }}
                    layout
                  >
                    <div className="flex justify-between items-start mb-1">
                      <div className="flex-1 min-w-0">
                        <motion.span 
                          className={`text-sm ${
                            !email.isRead && viewType === "inbox"
                              ? "text-slate-900 dark:text-white font-bold"
                              : "text-slate-700 dark:text-slate-300 font-medium"
                          }`}
                          whileHover={{ x: 5 }}
                          transition={{ type: "spring", stiffness: 300 }}
                        >
                          {otherParty}
                        </motion.span>
                      </div>
                      <div className="flex items-center gap-1 ml-2">
                        {viewType !== "trash" && (
                          <>
                            <motion.button
                              onClick={(e) => handleStarToggle(email.id, e)}
                              className={`p-1.5 rounded-lg transition-all hover:scale-110 active:scale-95 ${
                                email.isStarred 
                                  ? 'text-yellow-500 hover:text-yellow-600' 
                                  : 'text-slate-400 hover:text-yellow-500'
                              }`}
                              title={email.isStarred ? "Remove star" : "Star email"}
                              whileHover={{ scale: 1.1 }}
                              whileTap={{ scale: 0.9 }}
                            >
                              <svg className="w-4 h-4" fill={email.isStarred ? "currentColor" : "none"} stroke="currentColor" viewBox="0 0 24 24">
                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538 1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z" />
                              </svg>
                            </motion.button>
                          </>
                        )}
                        <span className="text-xs text-slate-500 dark:text-slate-400 whitespace-nowrap ml-1">
                          {formatDate(email.timestamp)}
                        </span>
                      </div>
                    </div>
                    <motion.div 
                      className={`text-sm truncate leading-relaxed ${
                        !email.isRead && viewType === "inbox"
                          ? "text-slate-800 dark:text-slate-200"
                          : "text-slate-500 dark:text-slate-400"
                      }`}
                      initial={{ opacity: 0 }}
                      animate={{ opacity: 1 }}
                      transition={{ delay: 0.1 + index * 0.02 }}
                    >
                      {isLocked || !privateKey
                        ? "üîê Unlock mailbox to read"
                        : decryptedSubjects[email.id] || "Decrypting..."}
                    </motion.div>
                  </motion.div>
                );
              })}
            </motion.div>
          </AnimatePresence>
        )}
      </div>
    </div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\ui\CryptaMailIcon.jsx -----
import React, { useState } from 'react';

export default function CryptaMailIcon({ size = 48, animated = true }) {
  const [isHovered, setIsHovered] = useState(false);
  const [isAnimating, setIsAnimating] = useState(false);

  const handleClick = () => {
    if (!animated) return;
    setIsAnimating(true);
    setTimeout(() => setIsAnimating(false), 1500);
  };

  return (
    <div
      style={{ width: size, height: size }}
      className="relative flex items-center justify-center cursor-pointer"
      onMouseEnter={() => setIsHovered(true)}
      onMouseLeave={() => setIsHovered(false)}
      onClick={handleClick}
    >
      <svg
        viewBox="0 0 48 48"
        className="w-full h-full"
      >
        <defs>
          <linearGradient id="iconGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#3B82F6" />
            <stop offset="50%" stopColor="#8B5CF6" />
            <stop offset="100%" stopColor="#06B6D4" />
          </linearGradient>
        </defs>

        {/* Envelope */}
        <g filter={isHovered || isAnimating ? "url(#iconGlow)" : ""}>
          <rect
            x="12"
            y="18"
            width="24"
            height="14"
            rx="2"
            fill="none"
            stroke="url(#iconGradient)"
            strokeWidth="1.5"
            className={isHovered || isAnimating ? "animate-pulse-slow" : ""}
          />

          <path
            d="M12 20 L24 28 L36 20"
            fill="none"
            stroke="url(#iconGradient)"
            strokeWidth="1.5"
            strokeLinecap="round"
            className={isHovered || isAnimating ? "animate-pulse-slow" : ""}
          />
        </g>

        {/* Lock icon with micro-interaction */}
        <g transform="translate(24, 25)">
          {/* Lock body */}
          <rect
            x="-3"
            y="-1"
            width="6"
            height="4"
            rx="1"
            fill="url(#iconGradient)"
            className={animated && isAnimating ? "animate-lock-micro" : ""}
          />

          {/* Lock shackle */}
          <path
            d="M-2,-1 A2,2 0 0,1 2,-1"
            fill="none"
            stroke="url(#iconGradient)"
            strokeWidth="1.5"
            strokeLinecap="round"
            className={animated && isAnimating ? "animate-shackle-micro" : ""}
          />
        </g>
      </svg>

      {animated && (
        <style>{`
          @keyframes pulse-slow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 0.8; }
          }
          
          @keyframes lock-micro {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
          }
          
          @keyframes shackle-micro {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(-15deg); }
          }
          
          .animate-pulse-slow {
            animation: pulse-slow 2s ease-in-out infinite;
          }
          
          .animate-lock-micro {
            animation: lock-micro 1.5s ease-in-out infinite;
          }
          
          .animate-shackle-micro {
            animation: shackle-micro 1.5s ease-in-out infinite;
          }
        `}</style>
      )}
    </div>
  );
}
import React from 'react';

export default function CryptaMailLogo({ width = 300, height = 300 }) {
  return (
    <div style={{ width, height }} className="relative">
      <svg
        viewBox="0 0 300 300"
        className="w-full h-full"
        style={{
          filter: 'drop-shadow(0 0 20px rgba(59, 130, 246, 0.5))'
        }}
      >
        <defs>
          {/* Gradients */}
          <linearGradient id="cipherGradient" x1="0%" y1="0%" x2="100%" y2="100%">
            <stop offset="0%" stopColor="#3B82F6" />
            <stop offset="50%" stopColor="#8B5CF6" />
            <stop offset="100%" stopColor="#06B6D4" />
          </linearGradient>
          
          <radialGradient id="glowGradient">
            <stop offset="0%" stopColor="#06B6D4" stopOpacity="0.8" />
            <stop offset="100%" stopColor="#3B82F6" stopOpacity="0.2" />
          </radialGradient>

          {/* Glow filter */}
          <filter id="glow">
            <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
            <feMerge>
              <feMergeNode in="coloredBlur"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>
        </defs>

        {/* Background glow circle */}
        <circle
          cx="150"
          cy="150"
          r="120"
          fill="url(#glowGradient)"
          opacity="0.3"
          className="animate-pulse"
        />

        {/* Encrypted binary code background */}
        <g opacity="0.3" className="animate-pulse">
          <text x="30" y="50" fill="#06B6D4" fontSize="8" fontFamily="monospace">
            01001011 11010010
          </text>
          <text x="200" y="80" fill="#8B5CF6" fontSize="8" fontFamily="monospace">
            10110101 01101100
          </text>
          <text x="40" y="250" fill="#3B82F6" fontSize="8" fontFamily="monospace">
            00111011 10010101
          </text>
          <text x="180" y="270" fill="#06B6D4" fontSize="8" fontFamily="monospace">
            11001010 10110011
          </text>
        </g>

        {/* Encrypted symbols floating */}
        <g className="animate-float-slow">
          <circle cx="60" cy="80" r="3" fill="#8B5CF6" opacity="0.8">
            <animate attributeName="opacity" values="0.8;0.3;0.8" dur="3s" repeatCount="indefinite"/>
          </circle>
          <circle cx="240" cy="100" r="2" fill="#06B6D4" opacity="0.6">
            <animate attributeName="opacity" values="0.6;0.2;0.6" dur="2.5s" repeatCount="indefinite"/>
          </circle>
          <circle cx="80" cy="220" r="2.5" fill="#3B82F6" opacity="0.7">
            <animate attributeName="opacity" values="0.7;0.3;0.7" dur="3.5s" repeatCount="indefinite"/>
          </circle>
          <circle cx="220" cy="200" r="2" fill="#8B5CF6" opacity="0.6">
            <animate attributeName="opacity" values="0.6;0.2;0.6" dur="2.8s" repeatCount="indefinite"/>
          </circle>
        </g>

        {/* Envelope shape */}
        <g className="animate-converge" filter="url(#glow)">
          {/* Envelope base */}
          <rect
            x="100"
            y="120"
            width="100"
            height="70"
            rx="8"
            fill="none"
            stroke="url(#cipherGradient)"
            strokeWidth="2"
            className="animate-draw"
          />
          
          {/* Envelope flap */}
          <path
            d="M100 125 L150 160 L200 125"
            fill="none"
            stroke="url(#cipherGradient)"
            strokeWidth="2"
            strokeLinecap="round"
            className="animate-draw-delayed"
          />
          
          {/* Center line */}
          <line
            x1="100"
            y1="175"
            x2="200"
            y2="175"
            stroke="url(#cipherGradient)"
            strokeWidth="1"
            opacity="0.5"
          />
        </g>

        {/* Lock icon */}
        <g className="animate-lock-appear" transform="translate(150, 150)">
          {/* Lock body */}
          <rect
            x="-8"
            y="-2"
            width="16"
            height="12"
            rx="2"
            fill="url(#cipherGradient)"
            opacity="0"
          >
            <animate attributeName="opacity" values="0;1" dur="0.5s" begin="2.5s" fill="freeze"/>
          </rect>
          
          {/* Lock shackle */}
          <path
            d="M-5,-2 A5,5 0 0,1 5,-2"
            fill="none"
            stroke="url(#cipherGradient)"
            strokeWidth="2"
            opacity="0"
            strokeLinecap="round"
          >
            <animate attributeName="opacity" values="0;1" dur="0.5s" begin="2.5s" fill="freeze"/>
            <animateTransform
              attributeName="transform"
              type="rotate"
              values="0 -5 0;-10 -5 0;-10 -5 0;0 -5 0"
              dur="0.5s"
              begin="3s"
              fill="freeze"
            />
          </path>
        </g>

        {/* Light particles */}
        <g className="animate-dissolve">
          {[...Array(12)].map((_, i) => (
            <circle
              key={i}
              cx={150 + Math.cos(i * 30 * Math.PI / 180) * 80}
              cy={150 + Math.sin(i * 30 * Math.PI / 180) * 80}
              r="1"
              fill="#06B6D4"
              opacity="0"
            >
              <animate 
                attributeName="opacity" 
                values="0;0.8;0" 
                dur="0.8s" 
                begin={`${3.2 + i * 0.1}s`} 
                fill="freeze"
              />
              <animate 
                attributeName="cy" 
                values={`${150 + Math.sin(i * 30 * Math.PI / 180) * 80};${150 + Math.sin(i * 30 * Math.PI / 180) * 100};${150 + Math.sin(i * 30 * Math.PI / 180) * 120}`} 
                dur="0.8s" 
                begin={`${3.2 + i * 0.1}s`} 
                fill="freeze"
              />
            </circle>
          ))}
        </g>

        {/* CryptaMail text */}
        <text
          x="150"
          y="220"
          textAnchor="middle"
          fontFamily="system-ui, -apple-system, sans-serif"
          fontSize="24"
          fontWeight="600"
          fill="#E5E7EB"
          opacity="0"
          className="animate-fade-in-text"
        >
          CryptaMail
        </text>
      </svg>

    </div>
  );
}



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\ui\CryptaMailSplash.jsx -----
import { useState, useEffect } from 'react';
import CryptaMailLogo from './CryptaMailLogo';

export default function CryptaMailSplash({ onComplete }) {
  const [showComplete, setShowComplete] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setShowComplete(true);
      if (onComplete) {
        setTimeout(onComplete, 500);
      }
    }, 4000); // Total animation duration

    return () => clearTimeout(timer);
  }, [onComplete]);

  return (
    <div className="fixed inset-0 bg-slate-950 dark:bg-black flex items-center justify-center z-50">
      <div className="relative">
        <CryptaMailLogo width={400} height={400} />

        {/* Continue button */}
        {showComplete && (
          <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2">
            <button
              onClick={onComplete}
              className="px-6 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors duration-200 font-medium animate-fade-in"
            >
              Continue to CryptaMail
            </button>
          </div>
        )}
      </div>

      <style>{`
        @keyframes fade-in {
          0% { opacity: 0; transform: translateY(10px); }
          100% { opacity: 1; transform: translateY(0px); }
        }
        
        .animate-fade-in {
          animation: fade-in 0.5s ease-out;
        }
      `}</style>
    </div>
  );
}
----- FILE: D:\CODES\ciphermailApp\frontend\src\components\ui\PageTransition.jsx -----
import { motion, AnimatePresence } from 'framer-motion';

const pageVariants = {
  initial: {
    opacity: 0,
    scale: 0.98,
    y: 20,
  },
  in: {
    opacity: 1,
    scale: 1,
    y: 0,
  },
  out: {
    opacity: 0,
    scale: 1.02,
    y: -20,
  },
};

const pageTransition = {
  type: 'tween',
  ease: 'anticipate',
  duration: 0.4,
};

const PageTransition = ({ children, location }) => {
  return (
    <AnimatePresence mode="wait">
      <motion.div
        key={location}
        initial="initial"
        animate="in"
        exit="out"
        variants={pageVariants}
        transition={pageTransition}
        className="w-full h-full"
      >
        {children}
      </motion.div>
    </AnimatePresence>
  );
};

export default PageTransition;



----- FILE: D:\CODES\ciphermailApp\frontend\src\components\ui\ParticleBackground.jsx -----
import { useEffect, useRef, useState } from 'react';
import { motion } from 'framer-motion';

const ParticleBackground = ({
  particleCount = 50,
  color = 'rgba(99, 102, 241, 0.1)',
  size = { min: 2, max: 6 },
  speed = { min: 0.5, max: 2 }
}) => {
  const canvasRef = useRef(null);
  const particlesRef = useRef([]);
  const animationRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');

    const resizeCanvas = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // ‚úÖ INIT PARTICLES (NO STATE)
    particlesRef.current = Array.from({ length: particleCount }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      size: Math.random() * (size.max - size.min) + size.min,
      speedX: (Math.random() - 0.5) * speed.max,
      speedY: (Math.random() - 0.5) * speed.max,
      opacity: Math.random() * 0.5 + 0.2
    }));

    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const particles = particlesRef.current;

      particles.forEach(p => {
        p.x += p.speedX;
        p.y += p.speedY;

        if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
        if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;

        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fillStyle = color.replace('0.1', p.opacity.toString());
        ctx.fill();
      });

      particles.forEach((p1, i) => {
        for (let j = i + 1; j < particles.length; j++) {
          const p2 = particles[j];
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < 150) {
            ctx.beginPath();
            ctx.strokeStyle = color.replace(
              '0.1',
              (0.1 * (1 - dist / 150)).toString()
            );
            ctx.lineWidth = 0.5;
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }
      });

      animationRef.current = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      window.removeEventListener('resize', resizeCanvas);
      cancelAnimationFrame(animationRef.current);
    };
  }, [particleCount, color, size.min, size.max, speed.max]);

  return (
    <canvas
      ref={canvasRef}
      className="fixed inset-0 pointer-events-none z-0"
    />
  );
};

export default ParticleBackground;
/**
 * Environment Configuration Module
 * Validates required environment variables and enforces HTTPS in production
 * This file is imported first in main.jsx to validate before app starts
 */

/**
 * Configuration object containing all environment variables
 */
export const config = {
  googleClientId: import.meta.env.VITE_GOOGLE_CLIENT_ID,
  apiBaseUrl: import.meta.env.VITE_API_BASE_URL,
  redirectUri: import.meta.env.VITE_GOOGLE_REDIRECT_URI,
  isDevelopment: import.meta.env.DEV,
  isProduction: import.meta.env.PROD,
};

/**
 * Validate that all required environment variables are set
 * @throws {Error} If required variables are missing or invalid
 */
function validateEnvironment() {
  const requiredVars = {
    VITE_GOOGLE_CLIENT_ID: 'Google OAuth Client ID',
    VITE_API_BASE_URL: 'Backend API base URL',
  };

  const missingVars = [];

  // Check required environment variables
  for (const [key, description] of Object.entries(requiredVars)) {
    const value = import.meta.env[key];

    if (!value) {
      missingVars.push(`${key} (${description})`);
    }

    // Check for placeholder values in any environment
    if (value && (value.includes('your_') || value.includes('YOUR_'))) {
      missingVars.push(
        `${key} contains a placeholder value - set a real value in your .env file (${description})`
      );
    }
  }

  if (missingVars.length > 0) {
    const errorMsg = `Missing or invalid environment variables:\n${missingVars
      .map((v) => `  - ${v}`)
      .join('\n')}`;

    if (import.meta.env.DEV) {
      console.error('‚ùå Environment Configuration Error:', errorMsg);
    }

    throw new Error(errorMsg);
  }

  // Validate API URL format
  const apiUrl = import.meta.env.VITE_API_BASE_URL;
  try {
    new URL(apiUrl);
  } catch (e) {
    const error = `Invalid API URL format: ${apiUrl}`;
    if (import.meta.env.DEV) {
      console.error('‚ùå Environment Configuration Error:', error);
    }
    throw new Error(error);
  }

  // Enforce HTTPS in production
  if (import.meta.env.PROD) {
    const urlObj = new URL(apiUrl);
    if (urlObj.protocol !== 'https:') {
      const error = `HTTPS is required in production. Got: ${urlObj.protocol}//${urlObj.host}`;
      if (import.meta.env.DEV) {
        console.error('‚ùå HTTPS Validation Error:', error);
      }
      throw new Error(error);
    }

    // Check redirect URI if present
    if (config.redirectUri) {
      try {
        const redirectObj = new URL(config.redirectUri);
        if (redirectObj.protocol !== 'https:') {
          const error = `HTTPS is required for redirect URI in production: ${config.redirectUri}`;
          if (import.meta.env.DEV) {
            console.error('‚ùå HTTPS Validation Error:', error);
          }
          throw new Error(error);
        }
      } catch (e) {
        const error = `Invalid redirect URI format: ${config.redirectUri}`;
        if (import.meta.env.DEV) {
          console.error('‚ùå Environment Configuration Error:', error);
        }
        throw new Error(error);
      }
    }
  }

  // Auto-redirect HTTP to HTTPS in production
  if (import.meta.env.PROD && window.location.protocol === 'http:') {
    const httpsUrl = window.location.href.replace(/^http:/, 'https:');
    window.location.href = httpsUrl;
    return; // Stop here, page will redirect
  }

  // Log success message
  if (import.meta.env.DEV) {
    console.log('‚úÖ Environment configuration validated successfully');
    console.log('  - API Base URL:', apiUrl);
    console.log('  - Google OAuth configured');
  }
}

// Validate environment immediately on module load
try {
  validateEnvironment();
} catch (error) {
  // In production, show error page; in development, error is logged above
  if (import.meta.env.PROD) {
    document.body.innerHTML = `
      <div style="
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        background: #f3f4f6;
        font-family: system-ui, -apple-system, sans-serif;
      ">
        <div style="
          background: white;
          padding: 2rem;
          border-radius: 0.5rem;
          box-shadow: 0 1px 3px rgba(0,0,0,0.1);
          max-width: 500px;
        ">
          <h1 style="color: #dc2626; margin: 0 0 1rem 0;">‚ö†Ô∏è Configuration Error</h1>
          <p style="margin: 0; color: #374151; line-height: 1.5;">
            The application could not start due to missing or invalid configuration.
          </p>
          <p style="margin: 1rem 0 0 0; color: #6b7280; font-size: 0.875rem;">
            Please check your environment variables and ensure all required settings are configured correctly.
          </p>
        </div>
      </div>
    `;
  }
  throw error;
}

export default config;




----- FILE: D:\CODES\ciphermailApp\frontend\src\context\GoogleProvider.jsx -----
import { GoogleOAuthProvider } from '@react-oauth/google';

export function GoogleAuthProvider({ children }) {
  return (
    <GoogleOAuthProvider
      clientId={import.meta.env.VITE_GOOGLE_CLIENT_ID || '738325871972-17u1a4eg758tb79nte81oijres6rachm.apps.googleusercontent.com'}
    >
      {children}
    </GoogleOAuthProvider>
  );
}



/**
 * Rate Limiter Utility
 * Client-side rate limiting to prevent brute force attacks
 * Uses in-memory Map storage for login attempt tracking
 */

const MAX_LOGIN_ATTEMPTS = 5;
const WINDOW_MS = 5 * 60 * 1000; // 5 minutes

// In-memory storage for login attempts
const loginAttempts = new Map();

/**
 * Format time remaining into human-readable string
 * @param {number} seconds - Seconds remaining
 * @returns {string} Formatted time string (e.g., "5m 30s" or "45s")
 */
function formatTimeRemaining(seconds) {
  if (seconds < 60) {
    return `${seconds}s`;
  }

  const minutes = Math.floor(seconds / 60);
  const secs = seconds % 60;

  if (secs === 0) {
    return `${minutes}m`;
  }

  return `${minutes}m ${secs}s`;
}

/**
 * Check if a login attempt is allowed
 * @param {string} username - Username attempting to login
 * @throws {Error} If rate limit exceeded with properties: waitSeconds, isRateLimitError
 */
export function checkLoginRateLimit(username) {
  const now = Date.now();
  const key = username.toLowerCase();

  // Initialize if needed
  if (!loginAttempts.has(key)) {
    loginAttempts.set(key, []);
  }

  const attempts = loginAttempts.get(key);

  // Remove attempts outside the time window
  const validAttempts = attempts.filter((timestamp) => now - timestamp < WINDOW_MS);

  if (validAttempts.length < MAX_LOGIN_ATTEMPTS) {
    // Add new attempt
    validAttempts.push(now);
    loginAttempts.set(key, validAttempts);

    if (import.meta.env.DEV) {
      console.log(
        `‚úÖ Login attempt allowed [${username}]: ${MAX_LOGIN_ATTEMPTS - validAttempts.length} attempts remaining`
      );
    }
    return;
  }

  // Rate limit exceeded
  const oldestAttempt = validAttempts[0];
  const resetTime = oldestAttempt + WINDOW_MS;
  const waitMs = Math.max(0, resetTime - now);
  const waitSeconds = Math.ceil(waitMs / 1000);
  const timeString = formatTimeRemaining(waitSeconds);

  if (import.meta.env.DEV) {
    console.warn(`‚ö†Ô∏è Rate limit exceeded [${username}]: wait ${timeString}`);
  }

  const error = new Error(`Too many login attempts. Please try again in ${timeString}`);
  error.waitSeconds = waitSeconds;
  error.isRateLimitError = true;

  throw error;
}

/**
 * Clear rate limit for a specific username (call after successful login)
 * @param {string} username - Username to clear
 */
export function clearLoginRateLimit(username) {
  const key = username.toLowerCase();

  if (loginAttempts.has(key)) {
    loginAttempts.delete(key);

    if (import.meta.env.DEV) {
      console.log(`‚úÖ Rate limit cleared for: ${username}`);
    }
  }
}

/**
 * Get remaining login attempts for a username
 * @param {string} username - Username to check
 * @returns {number} Number of attempts remaining (0 if rate limited)
 */
export function getRemainingAttempts(username) {
  const now = Date.now();
  const key = username.toLowerCase();

  if (!loginAttempts.has(key)) {
    return MAX_LOGIN_ATTEMPTS;
  }

  const attempts = loginAttempts.get(key);

  // Count attempts within the time window
  const validAttempts = attempts.filter((timestamp) => now - timestamp < WINDOW_MS);

  return Math.max(0, MAX_LOGIN_ATTEMPTS - validAttempts.length);
}

/**
 * SecurityLogger Utility
 * Logs security events for monitoring and audit trail purposes
 * Never logs sensitive data (passwords, tokens, private keys)
 */

class SecurityLogger {
  /**
   * Send a security log to the backend
   * @param {Object} eventData - Event data to log
   * @returns {Promise<void>}
   */
  static async sendLog(eventData) {
    try {
      const logEntry = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        ...eventData,
      };

      if (import.meta.env.DEV) {
        console.log('üìù Security Event:', logEntry);
      }

      // Only send to backend if endpoint exists
      if (import.meta.env.PROD || import.meta.env.VITE_API_BASE_URL) {
        const apiUrl = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8080/';
        const endpoint = `${apiUrl}/security/log`;

        // Use fetch to avoid circular dependencies with axios
        await fetch(endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(logEntry),
          credentials: 'include',
        }).catch((error) => {
          // Fail silently - backend endpoint might not exist yet
          if (import.meta.env.DEV) {
            console.debug('‚ö†Ô∏è Could not send security log to backend:', error.message);
          }
        });
      }
    } catch (error) {
      if (import.meta.env.DEV) {
        console.error('‚ùå SecurityLogger.sendLog error:', error);
      }
      // Fail silently to not disrupt user experience
    }
  }

  /**
   * Log a successful login event
   * @param {string} userId - User ID
   * @param {string} username - Username
   */
  static logSuccessfulLogin(userId, username) {
    SecurityLogger.sendLog({
      eventType: 'LOGIN_SUCCESS',
      severity: 'info',
      userId,
      username,
    });
  }

  /**
   * Log a failed login attempt
   * @param {string} username - Username of login attempt
   * @param {string} reason - Reason for failure
   */
  static logFailedLogin(username, reason = 'unknown') {
    SecurityLogger.sendLog({
      eventType: 'LOGIN_FAILED',
      severity: 'warning',
      username,
      reason,
    });
  }

  /**
   * Log a logout event
   * @param {string} userId - User ID
   * @param {string} reason - Reason for logout (user_initiated, session_timeout, etc.)
   */
  static logLogout(userId, reason = 'user_initiated') {
    SecurityLogger.sendLog({
      eventType: 'LOGOUT',
      severity: 'info',
      userId,
      reason,
    });
  }

  /**
   * Log rate limit exceeded event
   * @param {string} action - Action that was rate limited (e.g., 'login')
   * @param {string} identifier - Identifier (username, IP, user ID)
   * @param {number} waitSeconds - Seconds to wait before retry
   */
  static logRateLimitExceeded(action, identifier, waitSeconds) {
    SecurityLogger.sendLog({
      eventType: 'RATE_LIMIT_EXCEEDED',
      severity: 'warning',
      action,
      identifier,
      waitSeconds,
    });
  }

  /**
   * Log a security violation
   * @param {string} violationType - Type of violation
   * @param {Object} details - Additional details about the violation
   */
  static logSecurityViolation(violationType, details = {}) {
    SecurityLogger.sendLog({
      eventType: 'SECURITY_VIOLATION',
      severity: 'critical',
      violationType,
      ...details,
    });
  }
}

export default SecurityLogger;

----- FILE: D:\CODES\ciphermailApp\frontend\src\utils\validationUtils.js -----
/**
 * Frontend Validation Utilities
 * Provides validation for user inputs and API responses
 */

import DOMPurify from 'dompurify';

export const ValidationUtil = {
  /**
   * Validate email format - strict validation
   */
  isValidEmail: (email) => {
    if (!email || typeof email !== 'string') return false;
    // More strict email validation following RFC 5322 simplified
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]{2,}$/;
    if (!emailRegex.test(email)) return false;
    if (email.length > 254) return false;

    const [localPart, ...domainParts] = email.split('@');
    const domain = domainParts.join('@');

    // Check TLD
    const parts = domain.split('.');
    const tld = parts[parts.length - 1];
    if (tld.length < 2 || tld.length > 63) return false;

    // Block known disposable email domains
    const disposableDomains = new Set([
      'tempmail.com', 'guerrillamail.com', '10minutemail.com',
      'mailinator.com', 'temp-mail.org', 'throwaway.email'
    ]);

    if (disposableDomains.has(domain.toLowerCase())) return false;

    return true;
  },

  /**
   * Validate username (alphanumeric, dash, underscore, 3-32 chars)
   */
  isValidUsername: (username) => {
    if (!username || typeof username !== 'string') return false;
    const usernameRegex = /^[A-Za-z0-9_-]{3,32}$/;
    return usernameRegex.test(username);
  },

  /**
   * Validate password strength
   * - Minimum 12 characters (increased from 8)
   * - Maximum 128 characters
   * - At least one uppercase letter
   * - At least one lowercase letter
   * - At least one digit
   * - At least one special character
   * - No sequential patterns (123, abc, etc.)
   * - No repeated characters (aaa, 111, etc.)
   */
  isValidPassword: (password) => {
    if (!password || typeof password !== 'string') return false;
    if (password.length < 12 || password.length > 128) return false;

    const hasUppercase = /[A-Z]/.test(password);
    const hasLowercase = /[a-z]/.test(password);
    const hasDigit = /\d/.test(password);
    const hasSpecialChar = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>?]/.test(password);

    if (!hasUppercase || !hasLowercase || !hasDigit || !hasSpecialChar) {
      return false;
    }

    // Check for sequential patterns (123, abc, etc.)
    const sequentialRegex = /(?:(?:0(?=1)|1(?=2)|2(?=3)|3(?=4)|4(?=5)|5(?=6)|6(?=7)|7(?=8)|8(?=9)|a(?=b)|b(?=c)|c(?=d)|d(?=e)|e(?=f)|f(?=g)|g(?=h)|h(?=i)|i(?=j)|j(?=k)|k(?=l)|l(?=m)|m(?=n)|n(?=o)|o(?=p)|p(?=q)|q(?=r)|r(?=s)|s(?=t)|t(?=u)|u(?=v)|v(?=w)|w(?=x)|x(?=y)|y(?=z)){2})/i;
    if (sequentialRegex.test(password)) {
      return false;
    }

    // Check for repeated characters (aaa, 111, etc.)
    if (/(.)\1{2,}/.test(password)) {
      return false;
    }

    return true;
  },

  /**
   * Validate JWT token format
   */
  isValidJWTFormat: (token) => {
    if (!token || typeof token !== 'string') return false;
    const parts = token.split('.');
    return parts.length === 3 && parts.every(part => part.length > 0);
  },

  /**
   * Validate base64 encoded string
   */
  isValidBase64: (str) => {
    if (!str || typeof str !== 'string') return false;
    if (str.length % 4 !== 0) return false;
    const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
    return base64Regex.test(str);
  },

  /**
   * Sanitize input to prevent XSS attacks
   * Escapes HTML entities and validates length
   */
  sanitizeInput: (input) => {
    if (!input) return input;
    if (typeof input !== 'string') return '';

    // Limit input length
    if (input.length > 10000) return input.substring(0, 10000);

    // Use textContent to safely escape all HTML entities
    const div = document.createElement('div');
    div.textContent = input;
    return div.innerHTML;
  },

  /**
   * Validate API response structure
   */
  isValidResponse: (response) => {
    if (!response || typeof response !== 'object') return false;
    // Check if response has expected properties
    return 'data' in response || 'error' in response;
  },

  /**
   * Validate email list format
   */
  isValidEmailList: (emails) => {
    if (!Array.isArray(emails)) return false;
    return emails.every(email => 
      email && 
      typeof email === 'object' &&
      'id' in email &&
      'subject' in email
    );
  },

  /**
   * Sanitize HTML to prevent XSS - uses DOMPurify
   * Only allows safe HTML tags: b, i, em, strong, p, br, span, a
   * Only allows href and class attributes
   */
  sanitizeHTML: (html) => {
    if (!html || typeof html !== 'string') return '';
    
    const config = {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'p', 'br', 'span', 'a'],
      ALLOWED_ATTR: ['href', 'class'],
      ALLOW_DATA_ATTR: false,
      // Only allow https:// links
      ALLOWED_ATTR_NAMESPACES: ['data-href'],
    };

    let cleaned = DOMPurify.sanitize(html, config);

    // Additional validation: ensure only https:// links
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<div>${cleaned}</div>`, 'text/html');
    const links = doc.querySelectorAll('a[href]');

    links.forEach(link => {
      const href = link.getAttribute('href');
      if (href && !href.startsWith('https://') && !href.startsWith('http://') && !href.startsWith('mailto:')) {
        link.removeAttribute('href');
      }
    });

    return doc.body.innerHTML;
  }
};

export default ValidationUtil;
